/* This file is part of GDB.

   Copyright 2002, 2007 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   --

   This file was generated by the program igen */

#ifndef SUPPORT_C
#define SUPPORT_C

#include "sim-main.h"
#include "idecode.h"
#include "itable.h"
#include "support.h"

INLINE_SUPPORT\
(instruction_address)
semantic_illegal
(SIM_DESC sd,
 instruction_address cia)
{
#line 91 "./mips.igen"
  SignalException (ReservedInstruction, 0);
  sim_engine_abort (SD, CPU, cia, "Internal function must longjump\n");
  return cia;
}
#line 42 "support.c"

INLINE_SUPPORT\
(address_word)
delayslot32
(SIM_DESC sd, instruction_address cia, int MY_INDEX, address_word target)
{
#line 112 "./mips.igen"
  instruction_word delay_insn;
  sim_events_slip (SD, 1);
  DSPC = CIA;
  CIA = CIA + 4; /* NOTE not mips16 */
  STATE |= simDELAYSLOT;
  delay_insn = IMEM32 (CIA); /* NOTE not mips16 */
  ENGINE_ISSUE_PREFIX_HOOK();
  idecode_issue (CPU_, delay_insn, (CIA));
  STATE &= ~simDELAYSLOT;
  return target;
}
#line 61 "support.c"

INLINE_SUPPORT\
(address_word)
nullify_next_insn32
(SIM_DESC sd, instruction_address cia, int MY_INDEX)
{
#line 126 "./mips.igen"
  sim_events_slip (SD, 1);
  dotrace (SD, CPU, tracefh, 2, CIA + 4, 4, "load instruction");
  return CIA + 8;
}
#line 73 "support.c"

INLINE_SUPPORT\
(address_word)
loadstore_ea
(SIM_DESC sd, instruction_address cia, int MY_INDEX, address_word base, address_word offset)
{
#line 150 "./mips.igen"
  return base + offset;
}
#line 83 "support.c"

INLINE_SUPPORT\
(int)
not_word_value
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned_word value)
{
#line 192 "./mips.igen"
#if WITH_TARGET_WORD_BITSIZE == 64
  return value != (((value & 0xffffffff) ^ 0x80000000) - 0x80000000);
#else
  return 0;
#endif
}
#line 97 "support.c"

INLINE_SUPPORT\
(void)
unpredictable
(SIM_DESC sd, instruction_address cia, int MY_INDEX)
{
#line 217 "./mips.igen"
}
#line 106 "support.c"

INLINE_SUPPORT\
(int)
check_mf_cycles
(SIM_DESC sd, instruction_address cia, int MY_INDEX, hilo_history *history, signed64 time, const char *new)
{
#line 268 "./mips.igen"
  if (history->mf.timestamp + 3 > time)
    {
      sim_engine_abort (SD, CPU, CIA, "HILO: %s: %s at 0x%08lx too close to MF at 0x%08lx\n",
  			itable[MY_INDEX].name,
  			new, (long) CIA,
  			(long) history->mf.cia);
      return 0;
    }
  return 1;
}
#line 124 "support.c"

INLINE_SUPPORT\
(int)
check_mt_hilo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, hilo_history *history)
{
#line 303 "./mips.igen"
  signed64 time = sim_events_time (SD);
  int ok = (! MIPS_MACH_HAS_MT_HILO_HAZARD (SD)
  	    || check_mf_cycles (SD_, history, time, "MT"));
  history->mt.timestamp = time;
  history->mt.cia = CIA;
  return ok;
}
#line 139 "support.c"

INLINE_SUPPORT\
(int)
check_mf_hilo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, hilo_history *history, hilo_history *peer)
{
#line 348 "./mips.igen"
  signed64 time = sim_events_time (SD);
  int ok = 1;
  if (peer != NULL
      && peer->mt.timestamp > history->op.timestamp
      && history->mt.timestamp < history->op.timestamp
      && ! (history->mf.timestamp > history->op.timestamp
  	    && history->mf.timestamp < peer->mt.timestamp)
      && ! (peer->mf.timestamp > history->op.timestamp
  	    && peer->mf.timestamp < peer->mt.timestamp))
    {
      /* The peer has been written to since the last OP yet we have
         not */
      sim_engine_abort (SD, CPU, CIA, "HILO: %s: MF at 0x%08lx following OP at 0x%08lx corrupted by MT at 0x%08lx\n",
  			itable[MY_INDEX].name,
  			(long) CIA,
  			(long) history->op.cia,
  			(long) peer->mt.cia);
      ok = 0;
    }
  history->mf.timestamp = time;
  history->mf.cia = CIA;
  return ok;
}
#line 170 "support.c"

INLINE_SUPPORT\
(int)
check_mult_hilo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, hilo_history *hi, hilo_history *lo)
{
#line 400 "./mips.igen"
  signed64 time = sim_events_time (SD);
  int ok = (! MIPS_MACH_HAS_MULT_HILO_HAZARD (SD)
  	    || (check_mf_cycles (SD_, hi, time, "OP")
  	        && check_mf_cycles (SD_, lo, time, "OP")));
  hi->op.timestamp = time;
  lo->op.timestamp = time;
  hi->op.cia = CIA;
  lo->op.cia = CIA;
  return ok;
}
#line 188 "support.c"

INLINE_SUPPORT\
(int)
check_div_hilo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, hilo_history *hi, hilo_history *lo)
{
#line 457 "./mips.igen"
  signed64 time = sim_events_time (SD);
  int ok = (! MIPS_MACH_HAS_DIV_HILO_HAZARD (SD)
  	    || (check_mf_cycles (SD_, hi, time, "OP")
  	        && check_mf_cycles (SD_, lo, time, "OP")));
  hi->op.timestamp = time;
  lo->op.timestamp = time;
  hi->op.cia = CIA;
  lo->op.cia = CIA;
  return ok;
}
#line 206 "support.c"

INLINE_SUPPORT\
(void)
check_u64
(SIM_DESC sd, instruction_address cia, int MY_INDEX, instruction_word insn)
{
#line 500 "./mips.igen"
  // The check should be similar to mips64 for any with PX/UX bit equivalents.
}
#line 216 "support.c"

INLINE_SUPPORT\
(void)
do_add
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 529 "./mips.igen"
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  {
    ALU32_BEGIN (GPR[rs]);
    ALU32_ADD (GPR[rt]);
    ALU32_END (GPR[rd]);   /* This checks for overflow.  */
  }
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 234 "support.c"

INLINE_SUPPORT\
(void)
do_addi
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, unsigned16 immediate)
{
#line 542 "./mips.igen"
  if (NotWordValue (GPR[rs]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], EXTEND16 (immediate));
  {
    ALU32_BEGIN (GPR[rs]);
    ALU32_ADD (EXTEND16 (immediate));
    ALU32_END (GPR[rt]);   /* This checks for overflow.  */
  }
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 252 "support.c"

INLINE_SUPPORT\
(void)
do_andi
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, unsigned int immediate)
{
#line 555 "./mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], immediate);
  GPR[rt] = GPR[rs] & immediate;
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 264 "support.c"

INLINE_SUPPORT\
(void)
do_dadd
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt)
{
#line 562 "./mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  {
    ALU64_BEGIN (GPR[rs]);
    ALU64_ADD (GPR[rt]);
    ALU64_END (GPR[rd]);   /* This checks for overflow.  */
  }
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 280 "support.c"

INLINE_SUPPORT\
(void)
do_daddi
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rs, int immediate)
{
#line 573 "./mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], EXTEND16 (immediate));
  {
    ALU64_BEGIN (GPR[rs]);
    ALU64_ADD (EXTEND16 (immediate));
    ALU64_END (GPR[rt]);   /* This checks for overflow.  */
  }
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 296 "support.c"

INLINE_SUPPORT\
(void)
do_dsll32
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int shift)
{
#line 584 "./mips.igen"
  int s = 32 + shift;
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = GPR[rt] << s;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 309 "support.c"

INLINE_SUPPORT\
(void)
do_dsra32
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int shift)
{
#line 592 "./mips.igen"
  int s = 32 + shift;
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = ((signed64) GPR[rt]) >> s;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 322 "support.c"

INLINE_SUPPORT\
(void)
do_dsrl32
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int shift)
{
#line 600 "./mips.igen"
  int s = 32 + shift;
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = (unsigned64) GPR[rt] >> s;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 335 "support.c"

INLINE_SUPPORT\
(void)
do_dsub
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt)
{
#line 608 "./mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  {
    ALU64_BEGIN (GPR[rs]);
    ALU64_SUB (GPR[rt]);
    ALU64_END (GPR[rd]);   /* This checks for overflow.  */
  }
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 351 "support.c"

INLINE_SUPPORT\
(void)
do_break
(SIM_DESC sd, instruction_address cia, int MY_INDEX, address_word instruction_0)
{
#line 619 "./mips.igen"
  /* Check for some break instruction which are reserved for use by the
     simulator.  */
  unsigned int break_code = instruction_0 & HALT_INSTRUCTION_MASK;
  if (break_code == (HALT_INSTRUCTION  & HALT_INSTRUCTION_MASK) ||
      break_code == (HALT_INSTRUCTION2 & HALT_INSTRUCTION_MASK))
    {
      sim_engine_halt (SD, CPU, NULL, cia,
  		       sim_exited, (unsigned int)(A0 & 0xFFFFFFFF));
    }
  else if (break_code == (BREAKPOINT_INSTRUCTION  & HALT_INSTRUCTION_MASK) ||
  	   break_code == (BREAKPOINT_INSTRUCTION2 & HALT_INSTRUCTION_MASK))
    {
      if (STATE & simDELAYSLOT)
  	PC = cia - 4; /* reference the branch instruction */
      else
  	PC = cia;
      SignalException (BreakPoint, instruction_0);
    }

  else
    {
      /* If we get this far, we're not an instruction reserved by the sim.  Raise
  	 the exception. */
      SignalException (BreakPoint, instruction_0);
    }
}
#line 385 "support.c"

INLINE_SUPPORT\
(void)
do_break16
(SIM_DESC sd, instruction_address cia, int MY_INDEX, address_word instruction_0)
{
#line 648 "./mips.igen"
  if (STATE & simDELAYSLOT)
    PC = cia - 2; /* reference the branch instruction */
  else
    PC = cia;
  SignalException (BreakPoint, instruction_0);
}
#line 399 "support.c"

INLINE_SUPPORT\
(void)
do_clo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs)
{
#line 657 "./mips.igen"
  unsigned32 temp = GPR[rs];
  unsigned32 i, mask;
  if (NotWordValue (GPR[rs]))
    Unpredictable ();
  TRACE_ALU_INPUT1 (GPR[rs]);
  for (mask = ((unsigned32)1<<31), i = 0; i < 32; ++i)
    {
      if ((temp & mask) == 0)
  	break;
      mask >>= 1;
    }
  GPR[rd] = EXTEND32 (i);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 421 "support.c"

INLINE_SUPPORT\
(void)
do_clz
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs)
{
#line 674 "./mips.igen"
  unsigned32 temp = GPR[rs];
  unsigned32 i, mask;
  if (NotWordValue (GPR[rs]))
    Unpredictable ();
  TRACE_ALU_INPUT1 (GPR[rs]);
  for (mask = ((unsigned32)1<<31), i = 0; i < 32; ++i)
    {
      if ((temp & mask) != 0)
  	break;
      mask >>= 1;
    }
  GPR[rd] = EXTEND32 (i);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 443 "support.c"

INLINE_SUPPORT\
(void)
do_dclo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs)
{
#line 691 "./mips.igen"
  unsigned64 temp = GPR[rs];
  unsigned32 i;
  unsigned64 mask;
  TRACE_ALU_INPUT1 (GPR[rs]);
  for (mask = ((unsigned64)1<<63), i = 0; i < 64; ++i)
    {
      if ((temp & mask) == 0)
  	break;
      mask >>= 1;
    }
  GPR[rd] = EXTEND32 (i);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 464 "support.c"

INLINE_SUPPORT\
(void)
do_dclz
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs)
{
#line 707 "./mips.igen"
  unsigned64 temp = GPR[rs];
  unsigned32 i;
  unsigned64 mask;
  TRACE_ALU_INPUT1 (GPR[rs]);
  for (mask = ((unsigned64)1<<63), i = 0; i < 64; ++i)
    {
      if ((temp & mask) != 0)
  	break;
      mask >>= 1;
    }
  GPR[rd] = EXTEND32 (i);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 485 "support.c"

INLINE_SUPPORT\
(void)
do_lb
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int offset, int base)
{
#line 723 "./mips.igen"
  GPR[rt] = EXTEND8 (do_load (SD_, AccessLength_BYTE, GPR[base],
  			      EXTEND16 (offset)));
}
#line 496 "support.c"

INLINE_SUPPORT\
(void)
do_lh
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int offset, int base)
{
#line 729 "./mips.igen"
  GPR[rt] = EXTEND16 (do_load (SD_, AccessLength_HALFWORD, GPR[base],
  			       EXTEND16 (offset)));
}
#line 507 "support.c"

INLINE_SUPPORT\
(void)
do_lwr
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int offset, int base)
{
#line 735 "./mips.igen"
  GPR[rt] = EXTEND32 (do_load_right (SD_, AccessLength_WORD, GPR[base],
  				     EXTEND16 (offset), GPR[rt]));
}
#line 518 "support.c"

INLINE_SUPPORT\
(void)
do_lwl
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int offset, int base)
{
#line 741 "./mips.igen"
  GPR[rt] = EXTEND32 (do_load_left (SD_, AccessLength_WORD, GPR[base],
  				    EXTEND16 (offset), GPR[rt]));
}
#line 529 "support.c"

INLINE_SUPPORT\
(void)
do_lwc
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int num, int rt, int offset, int base)
{
#line 747 "./mips.igen"
  COP_LW (num, rt, do_load (SD_, AccessLength_WORD, GPR[base],
  			    EXTEND16 (offset)));
}
#line 540 "support.c"

INLINE_SUPPORT\
(void)
do_lw
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int offset, int base)
{
#line 753 "./mips.igen"
  GPR[rt] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[base],
  			       EXTEND16 (offset)));
}
#line 551 "support.c"

INLINE_SUPPORT\
(void)
do_lwu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int offset, int base, address_word instruction_0)
{
#line 759 "./mips.igen"
  check_u64 (SD_, instruction_0);
  GPR[rt] = do_load (SD_, AccessLength_WORD, GPR[base], EXTEND16 (offset));
}
#line 562 "support.c"

INLINE_SUPPORT\
(void)
do_lhu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int offset, int base)
{
#line 765 "./mips.igen"
  GPR[rt] = do_load (SD_, AccessLength_HALFWORD, GPR[base], EXTEND16 (offset));
}
#line 572 "support.c"

INLINE_SUPPORT\
(void)
do_ldc
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int num, int rt, int offset, int base)
{
#line 770 "./mips.igen"
  COP_LD (num, rt, do_load (SD_, AccessLength_DOUBLEWORD, GPR[base],
  			    EXTEND16 (offset)));
}
#line 583 "support.c"

INLINE_SUPPORT\
(void)
do_lbu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int offset, int base)
{
#line 776 "./mips.igen"
  GPR[rt] = do_load (SD_, AccessLength_BYTE, GPR[base], EXTEND16 (offset));
}
#line 593 "support.c"

INLINE_SUPPORT\
(void)
do_ll
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int insn_offset, int basereg)
{
#line 781 "./mips.igen"
  address_word base = GPR[basereg];
  address_word offset = EXTEND16 (insn_offset);
    {
      address_word vaddr = loadstore_ea (SD_, base, offset);
      address_word paddr = vaddr;
      if ((vaddr & 3) != 0)
  	{
  	  SIM_CORE_SIGNAL (SD, CPU, cia, read_map, 4, vaddr, read_transfer,
  			   sim_core_unaligned_signal);
  	}
      else
  	{
  	  unsigned64 memval = 0;
  	  unsigned64 memval1 = 0;
  	  unsigned64 mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  	  unsigned int shift = 2;
  	  unsigned int reverse = (ReverseEndian ? (mask >> shift) : 0);
  	  unsigned int bigend = (BigEndianCPU ? (mask >> shift) : 0);
  	  unsigned int byte;
  	  paddr = ((paddr & ~mask) | ((paddr & mask) ^ (reverse << shift)));
  	  LoadMemory (&memval, &memval1, AccessLength_WORD, paddr, vaddr,
  		      isDATA, isREAL);
  	  byte = ((vaddr & mask) ^ (bigend << shift));
  	  GPR[rt] = EXTEND32 (memval >> (8 * byte));
  	  LLBIT = 1;
  	}
    }
}
#line 629 "support.c"

INLINE_SUPPORT\
(void)
do_lld
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int roffset, int rbase)
{
#line 812 "./mips.igen"
  address_word base = GPR[rbase];
  address_word offset = EXTEND16 (roffset);
  {
    address_word vaddr = loadstore_ea (SD_, base, offset);
    address_word paddr = vaddr;

    if ((vaddr & 7) != 0)
      {
  	SIM_CORE_SIGNAL (SD, CPU, cia, read_map, 8, vaddr, read_transfer,
  		sim_core_unaligned_signal);
      }
    else
      {
  	unsigned64 memval = 0;
  	unsigned64 memval1 = 0;
  	LoadMemory (&memval, &memval1, AccessLength_DOUBLEWORD, paddr, vaddr,
  		    isDATA, isREAL);
  	GPR[rt] = memval;
  	LLBIT = 1;
      }
  }
}
#line 659 "support.c"

INLINE_SUPPORT\
(void)
do_lui
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int immediate)
{
#line 837 "./mips.igen"
  TRACE_ALU_INPUT1 (immediate);
  GPR[rt] = EXTEND32 (immediate << 16);
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 671 "support.c"

INLINE_SUPPORT\
(void)
do_madd
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt)
{
#line 844 "./mips.igen"
  signed64 temp;
  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  temp = (U8_4 (VL4_8 (HI), VL4_8 (LO))
  	  + ((signed64) EXTEND32 (GPR[rt]) * (signed64) EXTEND32 (GPR[rs])));
  LO = EXTEND32 (temp);
  HI = EXTEND32 (VH4_8 (temp));
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 690 "support.c"

INLINE_SUPPORT\
(void)
do_dsp_madd
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs, int rt)
{
#line 858 "./mips.igen"
  signed64 temp;
  if (ac == 0)
    check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  temp = (U8_4 (VL4_8 (DSPHI(ac)), VL4_8 (DSPLO(ac)))
  	  + ((signed64) EXTEND32 (GPR[rt]) * (signed64) EXTEND32 (GPR[rs])));
  DSPLO(ac) = EXTEND32 (temp);
  DSPHI(ac) = EXTEND32 (VH4_8 (temp));
  if (ac == 0)
    TRACE_ALU_RESULT2 (HI, LO);
}
#line 711 "support.c"

INLINE_SUPPORT\
(void)
do_maddu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt)
{
#line 874 "./mips.igen"
  unsigned64 temp;
  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  temp = (U8_4 (VL4_8 (HI), VL4_8 (LO))
  	  + ((unsigned64) VL4_8 (GPR[rs]) * (unsigned64) VL4_8 (GPR[rt])));
  ACX += U8_4 (VL4_8 (HI), VL4_8 (LO)) < temp;  /* SmartMIPS */
  LO = EXTEND32 (temp);
  HI = EXTEND32 (VH4_8 (temp));
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 731 "support.c"

INLINE_SUPPORT\
(void)
do_dsp_maddu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs, int rt)
{
#line 889 "./mips.igen"
  unsigned64 temp;
  if (ac == 0)
    check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  temp = (U8_4 (VL4_8 (DSPHI(ac)), VL4_8 (DSPLO(ac)))
  	  + ((unsigned64) VL4_8 (GPR[rs]) * (unsigned64) VL4_8 (GPR[rt])));
  if (ac == 0)
    ACX += U8_4 (VL4_8 (HI), VL4_8 (LO)) < temp;  /* SmartMIPS */
  DSPLO(ac) = EXTEND32 (temp);
  DSPHI(ac) = EXTEND32 (VH4_8 (temp));
  if (ac == 0)
    TRACE_ALU_RESULT2 (HI, LO);
}
#line 754 "support.c"

INLINE_SUPPORT\
(void)
do_dsp_mfhi
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rd)
{
#line 907 "./mips.igen"
  if (ac == 0)
    do_mfhi (SD_, rd);
  else
    GPR[rd] = DSPHI(ac);
}
#line 767 "support.c"

INLINE_SUPPORT\
(void)
do_dsp_mflo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rd)
{
#line 915 "./mips.igen"
  if (ac == 0)
    do_mflo (SD_, rd);
  else
    GPR[rd] = DSPLO(ac);
}
#line 780 "support.c"

INLINE_SUPPORT\
(void)
do_movn
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt)
{
#line 923 "./mips.igen"
  if (GPR[rt] != 0)
    {
      GPR[rd] = GPR[rs];
      TRACE_ALU_RESULT (GPR[rd]);
    }
}
#line 794 "support.c"

INLINE_SUPPORT\
(void)
do_movz
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt)
{
#line 932 "./mips.igen"
  if (GPR[rt] == 0)
    {
      GPR[rd] = GPR[rs];
      TRACE_ALU_RESULT (GPR[rd]);
    }
}
#line 808 "support.c"

INLINE_SUPPORT\
(void)
do_msub
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt)
{
#line 941 "./mips.igen"
  signed64 temp;
  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  temp = (U8_4 (VL4_8 (HI), VL4_8 (LO))
  	  - ((signed64) EXTEND32 (GPR[rt]) * (signed64) EXTEND32 (GPR[rs])));
  LO = EXTEND32 (temp);
  HI = EXTEND32 (VH4_8 (temp));
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 827 "support.c"

INLINE_SUPPORT\
(void)
do_dsp_msub
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs, int rt)
{
#line 955 "./mips.igen"
  signed64 temp;
  if (ac == 0)
    check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  temp = (U8_4 (VL4_8 (DSPHI(ac)), VL4_8 (DSPLO(ac)))
  	  - ((signed64) EXTEND32 (GPR[rt]) * (signed64) EXTEND32 (GPR[rs])));
  DSPLO(ac) = EXTEND32 (temp);
  DSPHI(ac) = EXTEND32 (VH4_8 (temp));
  if (ac == 0)
    TRACE_ALU_RESULT2 (HI, LO);
}
#line 848 "support.c"

INLINE_SUPPORT\
(void)
do_msubu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt)
{
#line 971 "./mips.igen"
  unsigned64 temp;
  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  temp = (U8_4 (VL4_8 (HI), VL4_8 (LO))
  	  - ((unsigned64) VL4_8 (GPR[rs]) * (unsigned64) VL4_8 (GPR[rt])));
  LO = EXTEND32 (temp);
  HI = EXTEND32 (VH4_8 (temp));
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 867 "support.c"

INLINE_SUPPORT\
(void)
do_dsp_msubu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs, int rt)
{
#line 985 "./mips.igen"
  unsigned64 temp;
  if (ac == 0)
    check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  temp = (U8_4 (VL4_8 (DSPHI(ac)), VL4_8 (DSPLO(ac)))
  	  - ((unsigned64) VL4_8 (GPR[rs]) * (unsigned64) VL4_8 (GPR[rt])));
  DSPLO(ac) = EXTEND32 (temp);
  DSPHI(ac) = EXTEND32 (VH4_8 (temp));
  if (ac == 0)
    TRACE_ALU_RESULT2 (HI, LO);
}
#line 888 "support.c"

INLINE_SUPPORT\
(void)
do_mthi
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs)
{
#line 1001 "./mips.igen"
  check_mt_hilo (SD_, HIHISTORY);
  HI = GPR[rs];
}
#line 899 "support.c"

INLINE_SUPPORT\
(void)
do_dsp_mthi
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs)
{
#line 1007 "./mips.igen"
  if (ac == 0)
    check_mt_hilo (SD_, HIHISTORY);
  DSPHI(ac) = GPR[rs];
}
#line 911 "support.c"

INLINE_SUPPORT\
(void)
do_mtlo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs)
{
#line 1014 "./mips.igen"
  check_mt_hilo (SD_, LOHISTORY);
  LO = GPR[rs];
}
#line 922 "support.c"

INLINE_SUPPORT\
(void)
do_dsp_mtlo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs)
{
#line 1020 "./mips.igen"
  if (ac == 0)
    check_mt_hilo (SD_, LOHISTORY);
  DSPLO(ac) = GPR[rs];
}
#line 934 "support.c"

INLINE_SUPPORT\
(void)
do_mul
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt)
{
#line 1027 "./mips.igen"
  signed64 prod;
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  prod = (((signed64)(signed32) GPR[rs])
  	  * ((signed64)(signed32) GPR[rt]));
  GPR[rd] = EXTEND32 (VL4_8 (prod));
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 951 "support.c"

INLINE_SUPPORT\
(void)
do_dsp_mult
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs, int rt)
{
#line 1039 "./mips.igen"
  signed64 prod;
  if (ac == 0)
    check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  prod = ((signed64)(signed32) GPR[rs])
  	  * ((signed64)(signed32) GPR[rt]);
  DSPLO(ac) = EXTEND32 (VL4_8 (prod));
  DSPHI(ac) = EXTEND32 (VH4_8 (prod));
  if (ac == 0)
  {
    ACX = 0;  /* SmartMIPS */
    TRACE_ALU_RESULT2 (HI, LO);
  }
}
#line 975 "support.c"

INLINE_SUPPORT\
(void)
do_dsp_multu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs, int rt)
{
#line 1058 "./mips.igen"
  unsigned64 prod;
  if (ac == 0)
    check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  prod = ((unsigned64)(unsigned32) GPR[rs])
          * ((unsigned64)(unsigned32) GPR[rt]);
  DSPLO(ac) = EXTEND32 (VL4_8 (prod));
  DSPHI(ac) = EXTEND32 (VH4_8 (prod));
  if (ac == 0)
    TRACE_ALU_RESULT2 (HI, LO);
}
#line 996 "support.c"

INLINE_SUPPORT\
(void)
do_pref
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int hint, int insn_offset, int insn_base)
{
#line 1074 "./mips.igen"
  address_word base = GPR[insn_base];
  address_word offset = EXTEND16 (insn_offset);
  {
    address_word vaddr = loadstore_ea (SD_, base, offset);
    address_word paddr = vaddr;
    /* Prefetch (paddr, vaddr, isDATA, hint); */
  }
}
#line 1012 "support.c"

INLINE_SUPPORT\
(void)
do_sc
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int offsetarg, int basereg, address_word instruction_0)
{
#line 1085 "./mips.igen"
  unsigned32 instruction = instruction_0;
  address_word base = GPR[basereg];
  address_word offset = EXTEND16 (offsetarg);
  {
    address_word vaddr = loadstore_ea (SD_, base, offset);
    address_word paddr = vaddr;

    if ((vaddr & 3) != 0)
      {
  	SIM_CORE_SIGNAL (SD, CPU, cia, read_map, 4, vaddr, write_transfer,
  			 sim_core_unaligned_signal);
      }
    else
      {
  	unsigned64 memval = 0;
  	unsigned64 memval1 = 0;
  	unsigned64 mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  	address_word reverseendian =
  	  (ReverseEndian ? (mask ^ AccessLength_WORD) : 0);
  	address_word bigendiancpu =
  	  (BigEndianCPU ? (mask ^ AccessLength_WORD) : 0);
  	unsigned int byte;
  	paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
  	byte = ((vaddr & mask) ^ bigendiancpu);
  	memval = ((unsigned64) GPR[rt] << (8 * byte));
  	if (LLBIT)
  	  StoreMemory (AccessLength_WORD, memval, memval1, paddr, vaddr,
  		        isREAL);
  	GPR[rt] = LLBIT;
      }
  }
}
#line 1052 "support.c"

INLINE_SUPPORT\
(void)
do_scd
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int roffset, int rbase)
{
#line 1120 "./mips.igen"
  address_word base = GPR[rbase];
  address_word offset = EXTEND16 (roffset);
  {
    address_word vaddr = loadstore_ea (SD_, base, offset);
    address_word paddr = vaddr;

    if ((vaddr & 7) != 0)
      {
  	SIM_CORE_SIGNAL (SD, CPU, cia, read_map, 8, vaddr, write_transfer,
  			 sim_core_unaligned_signal);
      }
    else
      {
  	unsigned64 memval = 0;
  	unsigned64 memval1 = 0;
  	memval = GPR[rt];
  	if (LLBIT)
  	  StoreMemory (AccessLength_DOUBLEWORD, memval, memval1, paddr, vaddr,
  		       isREAL);
  	GPR[rt] = LLBIT;
      }
  }
}
#line 1083 "support.c"

INLINE_SUPPORT\
(void)
do_sub
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 1146 "./mips.igen"
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  {
    ALU32_BEGIN (GPR[rs]);
    ALU32_SUB (GPR[rt]);
    ALU32_END (GPR[rd]);   /* This checks for overflow.  */
  }
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 1101 "support.c"

INLINE_SUPPORT\
(void)
do_sw
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int offset, int base)
{
#line 1159 "./mips.igen"
  do_store (SD_, AccessLength_WORD, GPR[base], EXTEND16 (offset), GPR[rt]);
}
#line 1111 "support.c"

INLINE_SUPPORT\
(void)
do_teq
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, address_word instruction_0)
{
#line 1164 "./mips.igen"
  if ((signed_word) GPR[rs] == (signed_word) GPR[rt])
    SignalException (Trap, instruction_0);
}
#line 1122 "support.c"

INLINE_SUPPORT\
(void)
do_teqi
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int immediate, address_word instruction_0)
{
#line 1170 "./mips.igen"
  if ((signed_word) GPR[rs] == (signed_word) EXTEND16 (immediate))
    SignalException (Trap, instruction_0);
}
#line 1133 "support.c"

INLINE_SUPPORT\
(void)
do_tge
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, address_word instruction_0)
{
#line 1176 "./mips.igen"
  if ((signed_word) GPR[rs] >= (signed_word) GPR[rt])
    SignalException (Trap, instruction_0);
}
#line 1144 "support.c"

INLINE_SUPPORT\
(void)
do_tgei
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int immediate, address_word instruction_0)
{
#line 1182 "./mips.igen"
  if ((signed_word) GPR[rs] >= (signed_word) EXTEND16 (immediate))
    SignalException (Trap, instruction_0);
}
#line 1155 "support.c"

INLINE_SUPPORT\
(void)
do_tgeiu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int immediate, address_word instruction_0)
{
#line 1188 "./mips.igen"
  if ((unsigned_word) GPR[rs] >= (unsigned_word) EXTEND16 (immediate))
    SignalException (Trap, instruction_0);
}
#line 1166 "support.c"

INLINE_SUPPORT\
(void)
do_tgeu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs ,int rt, address_word instruction_0)
{
#line 1194 "./mips.igen"
  if ((unsigned_word) GPR[rs] >= (unsigned_word) GPR[rt])
    SignalException (Trap, instruction_0);
}
#line 1177 "support.c"

INLINE_SUPPORT\
(void)
do_tlt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, address_word instruction_0)
{
#line 1200 "./mips.igen"
  if ((signed_word) GPR[rs] < (signed_word) GPR[rt])
    SignalException (Trap, instruction_0);
}
#line 1188 "support.c"

INLINE_SUPPORT\
(void)
do_tlti
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int immediate, address_word instruction_0)
{
#line 1206 "./mips.igen"
  if ((signed_word) GPR[rs] < (signed_word) EXTEND16 (immediate))
    SignalException (Trap, instruction_0);
}
#line 1199 "support.c"

INLINE_SUPPORT\
(void)
do_tltiu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int immediate, address_word instruction_0)
{
#line 1212 "./mips.igen"
  if ((unsigned_word) GPR[rs] < (unsigned_word) EXTEND16 (immediate))
    SignalException (Trap, instruction_0);
}
#line 1210 "support.c"

INLINE_SUPPORT\
(void)
do_tltu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, address_word instruction_0)
{
#line 1218 "./mips.igen"
  if ((unsigned_word) GPR[rs] < (unsigned_word) GPR[rt])
    SignalException (Trap, instruction_0);
}
#line 1221 "support.c"

INLINE_SUPPORT\
(void)
do_tne
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, address_word instruction_0)
{
#line 1224 "./mips.igen"
  if ((signed_word) GPR[rs] != (signed_word) GPR[rt])
    SignalException (Trap, instruction_0);
}
#line 1232 "support.c"

INLINE_SUPPORT\
(void)
do_tnei
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int immediate, address_word instruction_0)
{
#line 1230 "./mips.igen"
  if ((signed_word) GPR[rs] != (signed_word) EXTEND16 (immediate))
    SignalException (Trap, instruction_0);
}
#line 1243 "support.c"

INLINE_SUPPORT\
(void)
do_abs_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt, int fd, int fs, address_word instruction_0)
{
#line 1236 "./mips.igen"
  check_fpu (SD_);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (fd, fmt, AbsoluteValue (ValueFPR (fs, fmt), fmt));
}
#line 1255 "support.c"

INLINE_SUPPORT\
(void)
do_add_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt, int fd, int fs, int ft, address_word instruction_0)
{
#line 1243 "./mips.igen"
  check_fpu (SD_);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (fd, fmt, Add (ValueFPR (fs, fmt), ValueFPR (ft, fmt), fmt));
}
#line 1267 "support.c"

INLINE_SUPPORT\
(void)
do_alnv_ps
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fd, int fs, int ft, int rs, address_word instruction_0)
{
#line 1250 "./mips.igen"
  unsigned64 fsx;
  unsigned64 ftx;
  unsigned64 fdx;
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  fsx = ValueFPR (fs, fmt_ps);
  if ((GPR[rs] & 0x3) != 0)
    Unpredictable ();
  if ((GPR[rs] & 0x4) == 0)
    fdx = fsx;
  else
    {
      ftx = ValueFPR (ft, fmt_ps);
      if (BigEndianCPU)
  	fdx = PackPS (PSLower (fsx), PSUpper (ftx));
      else
  	fdx = PackPS (PSLower (ftx), PSUpper (fsx));
    }
  StoreFPR (fd, fmt_ps, fdx);
}
#line 1295 "support.c"

INLINE_SUPPORT\
(void)
do_c_cond_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int cond, int fmt, int cc, int fs, int ft, address_word instruction_0)
{
#line 1273 "./mips.igen"
  check_fpu (SD_);
  check_fmt_p (SD_, fmt, instruction_0);
  Compare (ValueFPR (fs, fmt), ValueFPR (ft, fmt), fmt, cond, cc);
  TRACE_ALU_RESULT (ValueFCR (31));
}
#line 1308 "support.c"

INLINE_SUPPORT\
(void)
do_ceil_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int type, int fmt, int fd, int fs, address_word instruction_0)
{
#line 1281 "./mips.igen"
  check_fpu (SD_);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (fd, type, Convert (FP_RM_TOPINF, ValueFPR (fs, fmt), fmt,
  	    type));
}
#line 1321 "support.c"

INLINE_SUPPORT\
(void)
do_cfc1
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int fs)
{
#line 1289 "./mips.igen"
  check_fpu (SD_);
  if (fs == 0 || fs == 25 || fs == 26 || fs == 28 || fs == 31)
    {
      unsigned_word  fcr = ValueFCR (fs);
      TRACE_ALU_INPUT1 (fcr);
      GPR[rt] = fcr;
    }
  /* else NOP */
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 1339 "support.c"

INLINE_SUPPORT\
(void)
do_ctc1
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int fs)
{
#line 1302 "./mips.igen"
  check_fpu (SD_);
  TRACE_ALU_INPUT1 (GPR[rt]);
  if (fs == 25 || fs == 26 || fs == 28 || fs == 31)
      StoreFCR (fs, GPR[rt]);
  /* else NOP */
}
#line 1353 "support.c"

INLINE_SUPPORT\
(void)
do_cvt_d_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt, int fd, int fs, address_word instruction_0)
{
#line 1311 "./mips.igen"
  check_fpu (SD_);
  if ((fmt == fmt_double) | 0)
    SignalException (ReservedInstruction, instruction_0);
  StoreFPR (fd, fmt_double, Convert (GETRM (), ValueFPR (fs, fmt), fmt,
  	    fmt_double));
}
#line 1367 "support.c"

INLINE_SUPPORT\
(void)
do_cvt_l_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt, int fd, int fs, address_word instruction_0)
{
#line 1320 "./mips.igen"
  check_fpu (SD_);
  if ((fmt == fmt_long) | ((fmt == fmt_long) || (fmt == fmt_word)))
    SignalException (ReservedInstruction, instruction_0);
  StoreFPR (fd, fmt_long, Convert (GETRM (), ValueFPR (fs, fmt), fmt,
  	    fmt_long));
}
#line 1381 "support.c"

INLINE_SUPPORT\
(void)
do_cvt_ps_s
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fd, int fs, int ft, address_word instruction_0)
{
#line 1329 "./mips.igen"
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  StoreFPR (fd, fmt_ps, PackPS (ValueFPR (fs, fmt_single),
  				ValueFPR (ft, fmt_single)));
}
#line 1394 "support.c"

INLINE_SUPPORT\
(void)
do_cvt_s_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt, int fd, int fs, address_word instruction_0)
{
#line 1337 "./mips.igen"
  check_fpu (SD_);
  if ((fmt == fmt_single) | 0)
    SignalException (ReservedInstruction, instruction_0);
  StoreFPR (fd, fmt_single, Convert (GETRM (), ValueFPR (fs, fmt), fmt,
  	    fmt_single));
}
#line 1408 "support.c"

INLINE_SUPPORT\
(void)
do_cvt_s_pl
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fd, int fs, address_word instruction_0)
{
#line 1346 "./mips.igen"
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  StoreFPR (fd, fmt_single, PSLower (ValueFPR (fs, fmt_ps)));
}
#line 1420 "support.c"

INLINE_SUPPORT\
(void)
do_cvt_s_pu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fd, int fs, address_word instruction_0)
{
#line 1353 "./mips.igen"
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  StoreFPR (fd, fmt_single, PSUpper (ValueFPR (fs, fmt_ps)));
}
#line 1432 "support.c"

INLINE_SUPPORT\
(void)
do_cvt_w_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt, int fd, int fs, address_word instruction_0)
{
#line 1360 "./mips.igen"
  check_fpu (SD_);
  if ((fmt == fmt_word) | ((fmt == fmt_long) || (fmt == fmt_word)))
    SignalException (ReservedInstruction, instruction_0);
  StoreFPR (fd, fmt_word, Convert (GETRM (), ValueFPR (fs, fmt), fmt,
  	    fmt_word));
}
#line 1446 "support.c"

INLINE_SUPPORT\
(void)
do_div_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt, int fd, int fs, int ft, address_word instruction_0)
{
#line 1369 "./mips.igen"
  check_fpu (SD_);
  StoreFPR (fd, fmt, Divide (ValueFPR (fs, fmt), ValueFPR (ft, fmt), fmt));
}
#line 1457 "support.c"

INLINE_SUPPORT\
(void)
do_dmfc1b
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int fs)
{
#line 1383 "./mips.igen"
  if (SizeFGR () == 64)
    GPR[rt] = FGR[fs];
  else if ((fs & 0x1) == 0)
    GPR[rt] = SET64HI (FGR[fs+1]) | FGR[fs];
  else
    GPR[rt] = SET64HI (0xDEADC0DE) | 0xBAD0BAD0;
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 1473 "support.c"

INLINE_SUPPORT\
(void)
do_dmtc1b
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int fs)
{
#line 1394 "./mips.igen"
  if (SizeFGR () == 64)
    StoreFPR (fs, fmt_uninterpreted_64, GPR[rt]);
  else if ((fs & 0x1) == 0)
    StoreFPR (fs, fmt_uninterpreted_64, GPR[rt]);
  else
    Unpredictable ();
}
#line 1488 "support.c"

INLINE_SUPPORT\
(void)
do_floor_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int type, int fmt, int fd, int fs)
{
#line 1404 "./mips.igen"
  check_fpu (SD_);
  StoreFPR (fd, type, Convert (FP_RM_TOMINF, ValueFPR (fs, fmt), fmt,
  	    type));
}
#line 1500 "support.c"

INLINE_SUPPORT\
(void)
do_luxc1_64
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fd, int rindex, int rbase)
{
#line 1427 "./mips.igen"
  address_word base = GPR[rbase];
  address_word index = GPR[rindex];
  address_word vaddr = base + index;
  if (SizeFGR () != 64)
    Unpredictable ();
  /* Arrange for the bottom 3 bits of (base + index) to be 0.  */
  if ((vaddr & 0x7) != 0)
    index -= (vaddr & 0x7);
  COP_LD (1, fd, do_load (SD_, AccessLength_DOUBLEWORD, base, index));

}
#line 1519 "support.c"

INLINE_SUPPORT\
(void)
do_lwc1
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ft, int offset, int base)
{
#line 1441 "./mips.igen"
  check_fpu (SD_);
  COP_LW (1, ft, do_load (SD_, AccessLength_WORD, GPR[base],
  			  EXTEND16 (offset)));
}
#line 1531 "support.c"

INLINE_SUPPORT\
(void)
do_lwxc1
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fd, int index, int base, address_word instruction_0)
{
#line 1448 "./mips.igen"
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  COP_LW (1, fd, do_load (SD_, AccessLength_WORD, GPR[base], GPR[index]));
}
#line 1543 "support.c"

INLINE_SUPPORT\
(void)
do_madd_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt, int fd, int fr, int fs, int ft, address_word instruction_0)
{
#line 1455 "./mips.igen"
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (fd, fmt, MultiplyAdd (ValueFPR (fs, fmt), ValueFPR (ft, fmt),
  				  ValueFPR (fr, fmt), fmt));
}
#line 1557 "support.c"

INLINE_SUPPORT\
(void)
do_mfc1b
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int fs)
{
#line 1464 "./mips.igen"
  check_fpu (SD_);
  GPR[rt] = EXTEND32 (FGR[fs]);
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 1569 "support.c"

INLINE_SUPPORT\
(void)
do_mov_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt, int fd, int fs, address_word instruction_0)
{
#line 1471 "./mips.igen"
  check_fpu (SD_);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (fd, fmt, ValueFPR (fs, fmt));
}
#line 1581 "support.c"

INLINE_SUPPORT\
(void)
do_movtf
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int tf, int rd, int rs, int cc)
{
#line 1478 "./mips.igen"
  check_fpu (SD_);
  if (GETFCC(cc) == tf)
    GPR[rd] = GPR[rs];
}
#line 1593 "support.c"

INLINE_SUPPORT\
(void)
do_movtf_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int tf, int fmt, int fd, int fs, int cc)
{
#line 1485 "./mips.igen"
  check_fpu (SD_);
  if (fmt != fmt_ps)
  {
    if (GETFCC(cc) == tf)
      StoreFPR (fd, fmt, ValueFPR (fs, fmt));
    else
      StoreFPR (fd, fmt, ValueFPR (fd, fmt));   /* set fmt */
  }
  else
  {
    unsigned64 fdx;
    fdx = PackPS (PSUpper (ValueFPR ((GETFCC (cc+1) == tf) ? fs : fd,
  				      fmt_ps)),
                  PSLower (ValueFPR ((GETFCC (cc+0) == tf) ? fs : fd,
  				      fmt_ps)));
    StoreFPR (fd, fmt_ps, fdx);
  }
}
#line 1619 "support.c"

INLINE_SUPPORT\
(void)
do_movn_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt, int fd, int fs, int rt)
{
#line 1506 "./mips.igen"
  check_fpu (SD_);
  if (GPR[rt] != 0)
    StoreFPR (fd, fmt, ValueFPR (fs, fmt));
  else
    StoreFPR (fd, fmt, ValueFPR (fd, fmt));
}
#line 1633 "support.c"

INLINE_SUPPORT\
(void)
do_movz_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt, int fd, int fs, int rt)
{
#line 1515 "./mips.igen"
  check_fpu (SD_);
  if (GPR[rt] == 0)
    StoreFPR (fd, fmt, ValueFPR (fs, fmt));
  else
    StoreFPR (fd, fmt, ValueFPR (fd, fmt));
}
#line 1647 "support.c"

INLINE_SUPPORT\
(void)
do_msub_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt, int fd, int fr, int fs, int ft, address_word instruction_0)
{
#line 1524 "./mips.igen"
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (fd, fmt, MultiplySub (ValueFPR (fs, fmt), ValueFPR (ft, fmt),
  				  ValueFPR (fr, fmt), fmt));
}
#line 1661 "support.c"

INLINE_SUPPORT\
(void)
do_mtc1b
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int fs)
{
#line 1533 "./mips.igen"
  check_fpu (SD_);
  StoreFPR (fs, fmt_uninterpreted_32, VL4_8 (GPR[rt]));
}
#line 1672 "support.c"

INLINE_SUPPORT\
(void)
do_mul_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt, int fd, int fs, int ft, address_word instruction_0)
{
#line 1539 "./mips.igen"
  check_fpu (SD_);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (fd, fmt, Multiply (ValueFPR (fs, fmt), ValueFPR (ft, fmt), fmt));
}
#line 1684 "support.c"

INLINE_SUPPORT\
(void)
do_neg_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt, int fd, int fs, address_word instruction_0)
{
#line 1546 "./mips.igen"
  check_fpu (SD_);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (fd, fmt, Negate (ValueFPR (fs, fmt), fmt));
}
#line 1696 "support.c"

INLINE_SUPPORT\
(void)
do_nmadd_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt, int fd, int fr, int fs, int ft, address_word instruction_0)
{
#line 1553 "./mips.igen"
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (fd, fmt, NegMultiplyAdd (ValueFPR (fs, fmt), ValueFPR (ft, fmt),
  				     ValueFPR (fr, fmt), fmt));
}
#line 1710 "support.c"

INLINE_SUPPORT\
(void)
do_nmsub_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt, int fd, int fr, int fs, int ft, address_word instruction_0)
{
#line 1562 "./mips.igen"
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (fd, fmt, NegMultiplySub (ValueFPR (fs, fmt), ValueFPR (ft, fmt),
  				     ValueFPR (fr, fmt), fmt));
}
#line 1724 "support.c"

INLINE_SUPPORT\
(void)
do_pll_ps
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fd, int fs, int ft, address_word instruction_0)
{
#line 1571 "./mips.igen"
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  StoreFPR (fd, fmt_ps, PackPS (PSLower (ValueFPR (fs, fmt_ps)),
  				PSLower (ValueFPR (ft, fmt_ps))));
}
#line 1737 "support.c"

INLINE_SUPPORT\
(void)
do_plu_ps
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fd, int fs, int ft, address_word instruction_0)
{
#line 1579 "./mips.igen"
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  StoreFPR (fd, fmt_ps, PackPS (PSLower (ValueFPR (fs, fmt_ps)),
  				PSUpper (ValueFPR (ft, fmt_ps))));
}
#line 1750 "support.c"

INLINE_SUPPORT\
(void)
do_pul_ps
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fd, int fs, int ft, address_word instruction_0)
{
#line 1587 "./mips.igen"
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  StoreFPR (fd, fmt_ps, PackPS (PSUpper (ValueFPR (fs, fmt_ps)),
  				PSLower (ValueFPR (ft, fmt_ps))));
}
#line 1763 "support.c"

INLINE_SUPPORT\
(void)
do_puu_ps
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fd, int fs, int ft, address_word instruction_0)
{
#line 1595 "./mips.igen"
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  StoreFPR (fd, fmt_ps, PackPS (PSUpper (ValueFPR (fs, fmt_ps)),
  				PSUpper (ValueFPR (ft, fmt_ps))));
}
#line 1776 "support.c"

INLINE_SUPPORT\
(void)
do_recip_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt, int fd, int fs)
{
#line 1603 "./mips.igen"
  check_fpu (SD_);
  StoreFPR (fd, fmt, Recip (ValueFPR (fs, fmt), fmt));
}
#line 1787 "support.c"

INLINE_SUPPORT\
(void)
do_round_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int type, int fmt, int fd, int fs)
{
#line 1609 "./mips.igen"
  check_fpu (SD_);
  StoreFPR (fd, type, Convert (FP_RM_NEAREST, ValueFPR (fs, fmt), fmt,
  	    type));
}
#line 1799 "support.c"

INLINE_SUPPORT\
(void)
do_rsqrt_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt, int fd, int fs)
{
#line 1616 "./mips.igen"
  check_fpu (SD_);
  StoreFPR (fd, fmt, RSquareRoot (ValueFPR (fs, fmt), fmt));
}
#line 1810 "support.c"

INLINE_SUPPORT\
(void)
do_prefx
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int hint, int rindex, int rbase)
{
#line 1622 "./mips.igen"
  address_word base = GPR[rbase];
  address_word index = GPR[rindex];
  {
    address_word vaddr = loadstore_ea (SD_, base, index);
    address_word paddr = vaddr;
    /* Prefetch (paddr, vaddr, isDATA, hint); */
  }
}
#line 1826 "support.c"

INLINE_SUPPORT\
(void)
do_suxc1_64
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fs, int rindex, int rbase)
{
#line 1659 "./mips.igen"
  address_word base = GPR[rbase];
  address_word index = GPR[rindex];
  address_word vaddr = base + index;
  if (SizeFGR () != 64)
    Unpredictable ();
  /* Arrange for the bottom 3 bits of (base + index) to be 0.  */
  if ((vaddr & 0x7) != 0)
    index -= (vaddr & 0x7);
  do_store (SD_, AccessLength_DOUBLEWORD, base, index, COP_SD (1, fs));
}
#line 1844 "support.c"

INLINE_SUPPORT\
(void)
do_sqrt_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt, int fd, int fs)
{
#line 1672 "./mips.igen"
  check_fpu (SD_);
  StoreFPR (fd, fmt,  (SquareRoot (ValueFPR (fs, fmt), fmt)));
}
#line 1855 "support.c"

INLINE_SUPPORT\
(void)
do_sub_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt, int fd, int fs, int ft, address_word instruction_0)
{
#line 1678 "./mips.igen"
  check_fpu (SD_);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (fd, fmt, Sub (ValueFPR (fs, fmt), ValueFPR (ft, fmt), fmt));
}
#line 1867 "support.c"

INLINE_SUPPORT\
(void)
do_swc1
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ft, int roffset, int rbase, address_word instruction_0)
{
#line 1685 "./mips.igen"
  address_word base = GPR[rbase];
  address_word offset = EXTEND16 (roffset);
  check_fpu (SD_);
  {
    address_word vaddr = loadstore_ea (SD_, base, offset);
    address_word paddr = vaddr;

    if ((vaddr & 3) != 0)
      {
  	SIM_CORE_SIGNAL (SD, CPU, cia, read_map, AccessLength_WORD+1, vaddr,
  			 write_transfer, sim_core_unaligned_signal);
      }
    else
      {
  	uword64 memval = 0;
  	uword64 memval1 = 0;
  	uword64 mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  	address_word reverseendian =
  	  (ReverseEndian ? (mask ^ AccessLength_WORD) : 0);
  	address_word bigendiancpu =
  	  (BigEndianCPU ? (mask ^ AccessLength_WORD) : 0);
  	unsigned int byte;
  	paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
  	byte = ((vaddr & mask) ^ bigendiancpu);
  	memval = (((uword64)COP_SW(1, ft)) << (8 * byte));
  	StoreMemory (AccessLength_WORD, memval, memval1, paddr, vaddr, isREAL);
      }
  }
}
#line 1904 "support.c"

INLINE_SUPPORT\
(void)
do_swxc1
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fs, int rindex, int rbase, address_word instruction_0)
{
#line 1717 "./mips.igen"
  address_word base = GPR[rbase];
  address_word index = GPR[rindex];
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
    {
      address_word vaddr = loadstore_ea (SD_, base, index);
      address_word paddr = vaddr;

      if ((vaddr & 3) != 0)
  	{
  	  SIM_CORE_SIGNAL (SD, CPU, cia, read_map, 4, vaddr, write_transfer,
  			   sim_core_unaligned_signal);
  	}
      else
  	{
  	  unsigned64 memval = 0;
  	  unsigned64 memval1 = 0;
  	  unsigned64 mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  	  address_word reverseendian =
  	    (ReverseEndian ? (mask ^ AccessLength_WORD) : 0);
  	  address_word bigendiancpu =
  	    (BigEndianCPU ? (mask ^ AccessLength_WORD) : 0);
  	  unsigned int byte;
  	  paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
  	  byte = ((vaddr & mask) ^ bigendiancpu);
  	  memval = (((unsigned64)COP_SW(1,fs)) << (8 * byte));
  	  StoreMemory (AccessLength_WORD, memval, memval1, paddr, vaddr,
  		       isREAL);
  	}
  }
}
#line 1943 "support.c"

INLINE_SUPPORT\
(void)
do_trunc_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int type, int fmt, int fd, int fs)
{
#line 1751 "./mips.igen"
  check_fpu (SD_);
  StoreFPR (fd, type, Convert (FP_RM_TOZERO, ValueFPR (fs, fmt), fmt,
  	    type));
}
#line 1955 "support.c"

INLINE_SUPPORT\
(void)
do_addiu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, unsigned16 immediate)
{
#line 1798 "./mips.igen"
  if (NotWordValue (GPR[rs]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], EXTEND16 (immediate));
  GPR[rt] = EXTEND32 (GPR[rs] + EXTEND16 (immediate));
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 1969 "support.c"

INLINE_SUPPORT\
(void)
do_addu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 1827 "./mips.igen"
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = EXTEND32 (GPR[rs] + GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 1983 "support.c"

INLINE_SUPPORT\
(void)
do_and
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 1856 "./mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = GPR[rs] & GPR[rt];
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 1995 "support.c"

INLINE_SUPPORT\
(void)
do_daddiu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, unsigned16 immediate)
{
#line 2399 "./mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], EXTEND16 (immediate));
  GPR[rt] = GPR[rs] + EXTEND16 (immediate);
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 2007 "support.c"

INLINE_SUPPORT\
(void)
do_daddu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 2422 "./mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = GPR[rs] + GPR[rt];
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 2019 "support.c"

INLINE_SUPPORT\
(void)
do_ddiv
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt)
{
#line 2473 "./mips.igen"
  check_div_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  {
    signed64 n = GPR[rs];
    signed64 d = GPR[rt];
    signed64 hi;
    signed64 lo;
    if (d == 0)
      {
  	lo = SIGNED64 (0x8000000000000000);
  	hi = 0;
      }
    else if (d == -1 && n == SIGNED64 (0x8000000000000000))
      {
  	lo = SIGNED64 (0x8000000000000000);
  	hi = 0;
      }
    else
      {
  	lo = (n / d);
  	hi = (n % d);
      }
    HI = hi;
    LO = lo;
  }
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 2054 "support.c"

INLINE_SUPPORT\
(void)
do_ddivu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt)
{
#line 2519 "./mips.igen"
  check_div_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  {
    unsigned64 n = GPR[rs];
    unsigned64 d = GPR[rt];
    unsigned64 hi;
    unsigned64 lo;
    if (d == 0)
      {
  	lo = SIGNED64 (0x8000000000000000);
  	hi = 0;
      }
    else
      {
  	lo = (n / d);
  	hi = (n % d);
      }
    HI = hi;
    LO = lo;
  }
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 2084 "support.c"

INLINE_SUPPORT\
(void)
do_div
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt)
{
#line 2558 "./mips.igen"
  check_div_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  {
    signed32 n = GPR[rs];
    signed32 d = GPR[rt];
    if (d == 0)
      {
  	LO = EXTEND32 (0x80000000);
  	HI = EXTEND32 (0);
      }
    else if (n == SIGNED32 (0x80000000) && d == -1)
      {
  	LO = EXTEND32 (0x80000000);
  	HI = EXTEND32 (0);
      }
    else
      {
  	LO = EXTEND32 (n / d);
  	HI = EXTEND32 (n % d);
      }
  }
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 2115 "support.c"

INLINE_SUPPORT\
(void)
do_divu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt)
{
#line 2604 "./mips.igen"
  check_div_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  {
    unsigned32 n = GPR[rs];
    unsigned32 d = GPR[rt];
    if (d == 0)
      {
  	LO = EXTEND32 (0x80000000);
  	HI = EXTEND32 (0);
      }
    else
      {
  	LO = EXTEND32 (n / d);
  	HI = EXTEND32 (n % d);
      }
  }
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 2141 "support.c"

INLINE_SUPPORT\
(void)
do_dmultx
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd, int signed_p)
{
#line 2644 "./mips.igen"
  unsigned64 lo;
  unsigned64 hi;
  unsigned64 m00;
  unsigned64 m01;
  unsigned64 m10;
  unsigned64 m11;
  unsigned64 mid;
  int sign;
  unsigned64 op1 = GPR[rs];
  unsigned64 op2 = GPR[rt];
  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  /* make signed multiply unsigned */
  sign = 0;
  if (signed_p)
    {
      if ((signed64) op1 < 0)
  	{
  	  op1 = - op1;
  	  ++sign;
  	}
      if ((signed64) op2 < 0)
  	{
  	  op2 = - op2;
  	  ++sign;
  	}
    }
  /* multiply out the 4 sub products */
  m00 = ((unsigned64) VL4_8 (op1) * (unsigned64) VL4_8 (op2));
  m10 = ((unsigned64) VH4_8 (op1) * (unsigned64) VL4_8 (op2));
  m01 = ((unsigned64) VL4_8 (op1) * (unsigned64) VH4_8 (op2));
  m11 = ((unsigned64) VH4_8 (op1) * (unsigned64) VH4_8 (op2));
  /* add the products */
  mid = ((unsigned64) VH4_8 (m00)
  	 + (unsigned64) VL4_8 (m10)
  	 + (unsigned64) VL4_8 (m01));
  lo = U8_4 (mid, m00);
  hi = (m11
  	+ (unsigned64) VH4_8 (mid)
  	+ (unsigned64) VH4_8 (m01)
  	+ (unsigned64) VH4_8 (m10));
  /* fix the sign */
  if (sign & 1)
    {
      lo = -lo;
      if (lo == 0)
  	hi = -hi;
      else
  	hi = -hi - 1;
    }
  /* save the result HI/LO (and a gpr) */
  LO = lo;
  HI = hi;
  if (rd != 0)
    GPR[rd] = lo;
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 2206 "support.c"

INLINE_SUPPORT\
(void)
do_dmult
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 2704 "./mips.igen"
  do_dmultx (SD_, rs, rt, rd, 1);
}
#line 2216 "support.c"

INLINE_SUPPORT\
(void)
do_dmultu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 2733 "./mips.igen"
  do_dmultx (SD_, rs, rt, rd, 0);
}
#line 2226 "support.c"

INLINE_SUPPORT\
(unsigned64)
do_dror
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned64 x,unsigned64 y)
{
#line 2761 "./mips.igen"
  unsigned64 result;

  y &= 63;
  TRACE_ALU_INPUT2 (x, y);
  result = ROTR64 (x, y);
  TRACE_ALU_RESULT (result);
  return result;
}
#line 2242 "support.c"

INLINE_SUPPORT\
(void)
do_dsll
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rd, int shift)
{
#line 2803 "./mips.igen"
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = GPR[rt] << shift;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 2254 "support.c"

INLINE_SUPPORT\
(void)
do_dsllv
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 2839 "./mips.igen"
  int s = MASKED64 (GPR[rs], 5, 0);
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = GPR[rt] << s;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 2267 "support.c"

INLINE_SUPPORT\
(void)
do_dsra
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rd, int shift)
{
#line 2861 "./mips.igen"
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = ((signed64) GPR[rt]) >> shift;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 2279 "support.c"

INLINE_SUPPORT\
(void)
do_dsrav
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 2899 "./mips.igen"
  int s = MASKED64 (GPR[rs], 5, 0);
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = ((signed64) GPR[rt]) >> s;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 2292 "support.c"

INLINE_SUPPORT\
(void)
do_dsrl
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rd, int shift)
{
#line 2921 "./mips.igen"
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = (unsigned64) GPR[rt] >> shift;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 2304 "support.c"

INLINE_SUPPORT\
(void)
do_dsrlv
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 2959 "./mips.igen"
  int s = MASKED64 (GPR[rs], 5, 0);
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = (unsigned64) GPR[rt] >> s;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 2317 "support.c"

INLINE_SUPPORT\
(void)
do_dsubu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 2999 "./mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = GPR[rs] - GPR[rt];
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 2329 "support.c"

INLINE_SUPPORT\
(unsigned_word)
do_load
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned access, address_word base, address_word offset)
{
#line 3123 "./mips.igen"
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? (mask ^ access) : 0);
  address_word bigendiancpu = (BigEndianCPU ? (mask ^ access) : 0);
  unsigned int byte;
  address_word paddr;
  unsigned64 memval;
  address_word vaddr;

  paddr = vaddr = loadstore_ea (SD_, base, offset);
  if ((vaddr & access) != 0)
    {
      SIM_CORE_SIGNAL (SD, STATE_CPU (SD, 0), cia, read_map, access+1, vaddr, read_transfer, sim_core_unaligned_signal);
    }
  paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
  LoadMemory (&memval, NULL, access, paddr, vaddr, isDATA, isREAL);
  byte = ((vaddr & mask) ^ bigendiancpu);
  return (memval >> (8 * byte));
}
#line 2355 "support.c"

INLINE_SUPPORT\
(unsigned_word)
do_load_left
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned access, address_word base, address_word offset, unsigned_word rt)
{
#line 3144 "./mips.igen"
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? -1 : 0);
  address_word bigendiancpu = (BigEndianCPU ? -1 : 0);
  unsigned int byte;
  unsigned int word;
  address_word paddr;
  unsigned64 memval;
  address_word vaddr;
  int nr_lhs_bits;
  int nr_rhs_bits;
  unsigned_word lhs_mask;
  unsigned_word temp;

  paddr = vaddr = loadstore_ea (SD_, base, offset);
  paddr = (paddr ^ (reverseendian & mask));
  if (BigEndianMem == 0)
    paddr = paddr & ~access;

  /* compute where within the word/mem we are */
  byte = ((vaddr ^ bigendiancpu) & access); /* 0..access */
  word = ((vaddr ^ bigendiancpu) & (mask & ~access)) / (access + 1); /* 0..1 */
  nr_lhs_bits = 8 * byte + 8;
  nr_rhs_bits = 8 * access - 8 * byte;
  /* nr_lhs_bits + nr_rhs_bits == 8 * (accesss + 1) */

  /* fprintf (stderr, "l[wd]l: 0x%08lx%08lx 0x%08lx%08lx %d:%d %d+%d\n",
  	   (long) ((unsigned64) vaddr >> 32), (long) vaddr,
  	   (long) ((unsigned64) paddr >> 32), (long) paddr,
  	   word, byte, nr_lhs_bits, nr_rhs_bits); */

  LoadMemory (&memval, NULL, byte, paddr, vaddr, isDATA, isREAL);
  if (word == 0)
    {
      /* GPR_31..32-NR_LHS_BITS_ = memval_NR_LHS_BITS-1..0_ */
      temp = (memval << nr_rhs_bits);
    }
  else
    {
      /* GPR_31..32-NR_LHS_BITS = memval_32+NR_LHS_BITS..32_ */
      temp = (memval >> nr_lhs_bits);
    }
  lhs_mask = LSMASK (nr_lhs_bits + nr_rhs_bits - 1, nr_rhs_bits);
  rt = (rt & ~lhs_mask) | (temp & lhs_mask);

  /* fprintf (stderr, "l[wd]l: 0x%08lx%08lx -> 0x%08lx%08lx & 0x%08lx%08lx -> 0x%08lx%08lx\n",
  	   (long) ((unsigned64) memval >> 32), (long) memval,
  	   (long) ((unsigned64) temp >> 32), (long) temp,
  	   (long) ((unsigned64) lhs_mask >> 32), (long) lhs_mask,
  	   (long) (rt >> 32), (long) rt); */
  return rt;
}
#line 2414 "support.c"

INLINE_SUPPORT\
(unsigned_word)
do_load_right
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned access, address_word base, address_word offset, unsigned_word rt)
{
#line 3198 "./mips.igen"
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? -1 : 0);
  address_word bigendiancpu = (BigEndianCPU ? -1 : 0);
  unsigned int byte;
  address_word paddr;
  unsigned64 memval;
  address_word vaddr;

  paddr = vaddr = loadstore_ea (SD_, base, offset);
  /* NOTE: SPEC is wrong, has `BigEndianMem == 0' not `BigEndianMem != 0' */
  paddr = (paddr ^ (reverseendian & mask));
  if (BigEndianMem != 0)
    paddr = paddr & ~access;
  byte = ((vaddr & mask) ^ (bigendiancpu & mask));
  /* NOTE: SPEC is wrong, had `byte' not `access - byte'.  See SW. */
  LoadMemory (&memval, NULL, access - (access & byte), paddr, vaddr, isDATA, isREAL);
  /* printf ("lr: 0x%08lx %d@0x%08lx 0x%08lx\n",
     (long) paddr, byte, (long) paddr, (long) memval); */
  {
    unsigned_word screen = LSMASK (8 * (access - (byte & access) + 1) - 1, 0);
    rt &= ~screen;
    rt |= (memval >> (8 * byte)) & screen;
  }
  return rt;
}
#line 2447 "support.c"

INLINE_SUPPORT\
(void)
do_mfhi
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd)
{
#line 3552 "./mips.igen"
  check_mf_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT1 (HI);
  GPR[rd] = HI;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 2460 "support.c"

INLINE_SUPPORT\
(void)
do_mflo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd)
{
#line 3588 "./mips.igen"
  check_mf_hilo (SD_, LOHISTORY, HIHISTORY);
  TRACE_ALU_INPUT1 (LO);
  GPR[rd] = LO;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 2473 "support.c"

INLINE_SUPPORT\
(void)
do_mult
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 3765 "./mips.igen"
  signed64 prod;
  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  prod = (((signed64)(signed32) GPR[rs])
  	  * ((signed64)(signed32) GPR[rt]));
  LO = EXTEND32 (VL4_8 (prod));
  HI = EXTEND32 (VH4_8 (prod));
  ACX = 0;  /* SmartMIPS */
  if (rd != 0)
    GPR[rd] = LO;
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 2495 "support.c"

INLINE_SUPPORT\
(void)
do_multu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 3818 "./mips.igen"
  unsigned64 prod;
  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  prod = (((unsigned64)(unsigned32) GPR[rs])
  	  * ((unsigned64)(unsigned32) GPR[rt]));
  LO = EXTEND32 (VL4_8 (prod));
  HI = EXTEND32 (VH4_8 (prod));
  if (rd != 0)
    GPR[rd] = LO;
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 2516 "support.c"

INLINE_SUPPORT\
(void)
do_nor
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 3870 "./mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = ~ (GPR[rs] | GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 2528 "support.c"

INLINE_SUPPORT\
(void)
do_or
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 3896 "./mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = (GPR[rs] | GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 2540 "support.c"

INLINE_SUPPORT\
(void)
do_ori
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, unsigned immediate)
{
#line 3923 "./mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], immediate);
  GPR[rt] = (GPR[rs] | immediate);
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 2552 "support.c"

INLINE_SUPPORT\
(unsigned64)
do_ror
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned32 x,unsigned32 y)
{
#line 3963 "./mips.igen"
  unsigned64 result;

  y &= 31;
  TRACE_ALU_INPUT2 (x, y);
  result = EXTEND32 (ROTR32 (x, y));
  TRACE_ALU_RESULT (result);
  return result;
}
#line 2568 "support.c"

INLINE_SUPPORT\
(void)
do_store
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned access, address_word base, address_word offset, unsigned_word word)
{
#line 3997 "./mips.igen"
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? (mask ^ access) : 0);
  address_word bigendiancpu = (BigEndianCPU ? (mask ^ access) : 0);
  unsigned int byte;
  address_word paddr;
  unsigned64 memval;
  address_word vaddr;

  paddr = vaddr = loadstore_ea (SD_, base, offset);
  if ((vaddr & access) != 0)
    {
      SIM_CORE_SIGNAL (SD, STATE_CPU(SD, 0), cia, read_map, access+1, vaddr, write_transfer, sim_core_unaligned_signal);
    }
  paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
  byte = ((vaddr & mask) ^ bigendiancpu);
  memval = (word << (8 * byte));
  StoreMemory (access, memval, 0, paddr, vaddr, isREAL);
}
#line 2594 "support.c"

INLINE_SUPPORT\
(void)
do_store_left
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned access, address_word base, address_word offset, unsigned_word rt)
{
#line 4018 "./mips.igen"
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? -1 : 0);
  address_word bigendiancpu = (BigEndianCPU ? -1 : 0);
  unsigned int byte;
  unsigned int word;
  address_word paddr;
  unsigned64 memval;
  address_word vaddr;
  int nr_lhs_bits;
  int nr_rhs_bits;

  paddr = vaddr = loadstore_ea (SD_, base, offset);
  paddr = (paddr ^ (reverseendian & mask));
  if (BigEndianMem == 0)
    paddr = paddr & ~access;

  /* compute where within the word/mem we are */
  byte = ((vaddr ^ bigendiancpu) & access); /* 0..access */
  word = ((vaddr ^ bigendiancpu) & (mask & ~access)) / (access + 1); /* 0..1 */
  nr_lhs_bits = 8 * byte + 8;
  nr_rhs_bits = 8 * access - 8 * byte;
  /* nr_lhs_bits + nr_rhs_bits == 8 * (accesss + 1) */
  /* fprintf (stderr, "s[wd]l: 0x%08lx%08lx 0x%08lx%08lx %d:%d %d+%d\n",
  	   (long) ((unsigned64) vaddr >> 32), (long) vaddr,
  	   (long) ((unsigned64) paddr >> 32), (long) paddr,
  	   word, byte, nr_lhs_bits, nr_rhs_bits); */

  if (word == 0)
    {
      memval = (rt >> nr_rhs_bits);
    }
  else
    {
      memval = (rt << nr_lhs_bits);
    }
  /* fprintf (stderr, "s[wd]l: 0x%08lx%08lx -> 0x%08lx%08lx\n",
  	   (long) ((unsigned64) rt >> 32), (long) rt,
  	   (long) ((unsigned64) memval >> 32), (long) memval); */
  StoreMemory (byte, memval, 0, paddr, vaddr, isREAL);
}
#line 2642 "support.c"

INLINE_SUPPORT\
(void)
do_store_right
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned access, address_word base, address_word offset, unsigned_word rt)
{
#line 4061 "./mips.igen"
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? -1 : 0);
  address_word bigendiancpu = (BigEndianCPU ? -1 : 0);
  unsigned int byte;
  address_word paddr;
  unsigned64 memval;
  address_word vaddr;

  paddr = vaddr = loadstore_ea (SD_, base, offset);
  paddr = (paddr ^ (reverseendian & mask));
  if (BigEndianMem != 0)
    paddr &= ~access;
  byte = ((vaddr & mask) ^ (bigendiancpu & mask));
  memval = (rt << (byte * 8));
  StoreMemory (access - (access & byte), memval, 0, paddr, vaddr, isREAL);
}
#line 2666 "support.c"

INLINE_SUPPORT\
(void)
do_sll
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rd, int shift)
{
#line 4214 "./mips.igen"
  unsigned32 temp = (GPR[rt] << shift);
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 2679 "support.c"

INLINE_SUPPORT\
(void)
do_sllv
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 4256 "./mips.igen"
  int s = MASKED (GPR[rs], 4, 0);
  unsigned32 temp = (GPR[rt] << s);
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 2693 "support.c"

INLINE_SUPPORT\
(void)
do_slt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 4284 "./mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = ((signed_word) GPR[rs] < (signed_word) GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 2705 "support.c"

INLINE_SUPPORT\
(void)
do_slti
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, unsigned16 immediate)
{
#line 4310 "./mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], EXTEND16 (immediate));
  GPR[rt] = ((signed_word) GPR[rs] < (signed_word) EXTEND16 (immediate));
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 2717 "support.c"

INLINE_SUPPORT\
(void)
do_sltiu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, unsigned16 immediate)
{
#line 4336 "./mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], EXTEND16 (immediate));
  GPR[rt] = ((unsigned_word) GPR[rs] < (unsigned_word) EXTEND16 (immediate));
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 2729 "support.c"

INLINE_SUPPORT\
(void)
do_sltu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 4363 "./mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = ((unsigned_word) GPR[rs] < (unsigned_word) GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 2741 "support.c"

INLINE_SUPPORT\
(void)
do_sra
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rd, int shift)
{
#line 4389 "./mips.igen"
  signed32 temp = (signed32) GPR[rt] >> shift;
  if (NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 2756 "support.c"

INLINE_SUPPORT\
(void)
do_srav
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 4419 "./mips.igen"
  int s = MASKED (GPR[rs], 4, 0);
  signed32 temp = (signed32) GPR[rt] >> s;
  if (NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 2772 "support.c"

INLINE_SUPPORT\
(void)
do_srl
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rd, int shift)
{
#line 4450 "./mips.igen"
  unsigned32 temp = (unsigned32) GPR[rt] >> shift;
  if (NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 2787 "support.c"

INLINE_SUPPORT\
(void)
do_srlv
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 4479 "./mips.igen"
  int s = MASKED (GPR[rs], 4, 0);
  unsigned32 temp = (unsigned32) GPR[rt] >> s;
  if (NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 2803 "support.c"

INLINE_SUPPORT\
(void)
do_subu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 4528 "./mips.igen"
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = EXTEND32 (GPR[rs] - GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 2817 "support.c"

INLINE_SUPPORT\
(void)
do_xor
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 4874 "./mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = GPR[rs] ^ GPR[rt];
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 2829 "support.c"

INLINE_SUPPORT\
(void)
do_xori
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, unsigned16 immediate)
{
#line 4900 "./mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], immediate);
  GPR[rt] = GPR[rs] ^ immediate;
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 2841 "support.c"

INLINE_SUPPORT\
(const char *)
str_FMT
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt)
{
#line 4933 "./mips.igen"
  switch (fmt)
    {
    case fmt_single: return "s";
    case fmt_double: return "d";
    case fmt_word: return "w";
    case fmt_long: return "l";
    case fmt_ps: return "ps";
    default: return "?";
    }
}
#line 2859 "support.c"

INLINE_SUPPORT\
(const char *)
str_TF
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int tf)
{
#line 4946 "./mips.igen"
  if (tf)
    return "t";
  else
    return "f";
}
#line 2872 "support.c"

INLINE_SUPPORT\
(const char *)
str_ND
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int nd)
{
#line 4954 "./mips.igen"
  if (nd)
    return "l";
  else
    return "";
}
#line 2885 "support.c"

INLINE_SUPPORT\
(const char *)
str_COND
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int cond)
{
#line 4962 "./mips.igen"
  switch (cond)
    {
    case 00: return "f";
    case 01: return "un";
    case 02: return "eq";
    case 03: return "ueq";
    case 04: return "olt";
    case 05: return "ult";
    case 06: return "ole";
    case 07: return "ule";
    case 010: return "sf";
    case 011: return "ngle";
    case 012: return "seq";
    case 013: return "ngl";
    case 014: return "lt";
    case 015: return "nge";
    case 016: return "le";
    case 017: return "ngt";
    default: return "?";
    }
}
#line 2914 "support.c"

INLINE_SUPPORT\
(void)
check_fmt_p
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt, instruction_word insn)
{
#line 5002 "./mips.igen"
  /* None of these ISAs support Paired Single, so just fall back to
     the single/double check.  */
  if ((fmt != fmt_single) && (fmt != fmt_double))
    SignalException (ReservedInstruction, insn);
}
#line 2927 "support.c"

INLINE_SUPPORT\
(void)
check_fpu
(SIM_DESC sd, instruction_address cia, int MY_INDEX)
{
#line 5050 "./mips.igen"
  if (! COP_Usable (1))
    SignalExceptionCoProcessorUnusable (1);
}
#line 2938 "support.c"

INLINE_SUPPORT\
(void)
do_dsbh
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt)
{
#line 24 "mips3264r2.igen"
  union { unsigned64 d; unsigned16 h[4]; } u;
  TRACE_ALU_INPUT1 (GPR[rt]);
  u.d = GPR[rt];
  u.h[0] = SWAP_2 (u.h[0]);
  u.h[1] = SWAP_2 (u.h[1]);
  u.h[2] = SWAP_2 (u.h[2]);
  u.h[3] = SWAP_2 (u.h[3]);
  GPR[rd] = u.d;
  TRACE_ALU_RESULT1 (GPR[rd]);
}
#line 2956 "support.c"

INLINE_SUPPORT\
(void)
do_dshd
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt)
{
#line 37 "mips3264r2.igen"
  unsigned64 d;
  TRACE_ALU_INPUT1 (GPR[rt]);
  d = GPR[rt];
  GPR[rd] = ((d >> 48)
  	     | (d << 48)
  	     | ((d & 0x0000ffff00000000ULL) >> 16)
  	     | ((d & 0x00000000ffff0000ULL) << 16));
  TRACE_ALU_RESULT1 (GPR[rd]);
}
#line 2973 "support.c"

INLINE_SUPPORT\
(void)
do_dext
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rs, int lsb, int size)
{
#line 49 "mips3264r2.igen"
  TRACE_ALU_INPUT3 (GPR[rs], lsb, size);
  GPR[rt] = EXTRACTED64 (GPR[rs], lsb + size, lsb);
  TRACE_ALU_RESULT1 (GPR[rt]);
}
#line 2985 "support.c"

INLINE_SUPPORT\
(void)
do_dextm
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rs, int lsb, int size)
{
#line 56 "mips3264r2.igen"
  TRACE_ALU_INPUT3 (GPR[rs], lsb, size);
  GPR[rt] = EXTRACTED64 (GPR[rs], lsb + size + 32, lsb);
  TRACE_ALU_RESULT1 (GPR[rt]);
}
#line 2997 "support.c"

INLINE_SUPPORT\
(void)
do_dextu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rs, int lsb, int size)
{
#line 63 "mips3264r2.igen"
  TRACE_ALU_INPUT3 (GPR[rs], lsb, size);
  GPR[rt] = EXTRACTED64 (GPR[rs], lsb + 32 + size, lsb + 32);
  TRACE_ALU_RESULT1 (GPR[rt]);
}
#line 3009 "support.c"

INLINE_SUPPORT\
(void)
do_di
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt)
{
#line 70 "mips3264r2.igen"
  TRACE_ALU_INPUT0 ();
  GPR[rt] = EXTEND32 (SR);
  SR &= ~status_IE;
  TRACE_ALU_RESULT1 (GPR[rt]);
}
#line 3022 "support.c"

INLINE_SUPPORT\
(void)
do_dins
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rs, int lsb, int msb)
{
#line 78 "mips3264r2.igen"
  TRACE_ALU_INPUT4 (GPR[rt], GPR[rs], lsb, msb);
  if (lsb <= msb)
    GPR[rt] ^= (GPR[rt] ^ (GPR[rs] << lsb)) & MASK64 (msb, lsb);
  TRACE_ALU_RESULT1 (GPR[rt]);
}
#line 3035 "support.c"

INLINE_SUPPORT\
(void)
do_dinsm
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rs, int lsb, int msb)
{
#line 86 "mips3264r2.igen"
  TRACE_ALU_INPUT4 (GPR[rt], GPR[rs], lsb, msb);
  if (lsb <= msb + 32)
    GPR[rt] ^= (GPR[rt] ^ (GPR[rs] << lsb)) & MASK64 (msb + 32, lsb);
  TRACE_ALU_RESULT1 (GPR[rt]);
}
#line 3048 "support.c"

INLINE_SUPPORT\
(void)
do_ei
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt)
{
#line 94 "mips3264r2.igen"
  TRACE_ALU_INPUT0 ();
  GPR[rt] = EXTEND32 (SR);
  SR |= status_IE;
  TRACE_ALU_RESULT1 (GPR[rt]);
}
#line 3061 "support.c"

INLINE_SUPPORT\
(void)
do_ext
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rs, int lsb, int size)
{
#line 102 "mips3264r2.igen"
  TRACE_ALU_INPUT3 (GPR[rs], lsb, size);
  GPR[rt] = EXTEND32 (EXTRACTED32 (GPR[rs], lsb + size, lsb));
  TRACE_ALU_RESULT1 (GPR[rt]);
}
#line 3073 "support.c"

INLINE_SUPPORT\
(void)
do_mfhc1
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int fs)
{
#line 109 "mips3264r2.igen"
  check_fpu (SD_);
  if (SizeFGR() == 64)
    GPR[rt] = EXTEND32 (WORD64HI (FGR[fs]));
  else if ((fs & 0x1) == 0)
    GPR[rt] = EXTEND32 (FGR[fs + 1]);
  else
    {
      if (STATE_VERBOSE_P(SD))
  	sim_io_eprintf (SD,
  	         "Warning: PC 0x%lx: MFHC1 32-bit use of odd FPR number\n",
  			(long) CIA);
      GPR[rt] = EXTEND32 (0xBADF00D);
    }
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 3096 "support.c"

INLINE_SUPPORT\
(void)
do_mthc1
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int fs)
{
#line 127 "mips3264r2.igen"
  check_fpu (SD_);
  if (SizeFGR() == 64)
    StoreFPR (fs, fmt_uninterpreted_64, SET64HI (GPR[rt]) | VL4_8 (FGR[fs]));
  else if ((fs & 0x1) == 0)
    StoreFPR (fs + 1, fmt_uninterpreted_32, VL4_8 (GPR[rt]));
  else
    {
      if (STATE_VERBOSE_P(SD))
  	sim_io_eprintf (SD,
  	         "Warning: PC 0x%lx: MTHC1 32-bit use of odd FPR number\n",
  			(long) CIA);
      StoreFPR (fs, fmt_uninterpreted_32, 0xDEADC0DE);
    }
  TRACE_FP_RESULT (GPR[rt]);
}
#line 3119 "support.c"

INLINE_SUPPORT\
(void)
do_ins
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rs, int lsb, int msb)
{
#line 145 "mips3264r2.igen"
  TRACE_ALU_INPUT4 (GPR[rt], GPR[rs], lsb, msb);
  if (lsb <= msb)
    GPR[rt] = EXTEND32 (GPR[rt] ^
  			((GPR[rt] ^ (GPR[rs] << lsb)) & MASK32 (msb, lsb)));
  TRACE_ALU_RESULT1 (GPR[rt]);
}
#line 3133 "support.c"

INLINE_SUPPORT\
(void)
do_dinsu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rs, int lsb, int msb)
{
#line 154 "mips3264r2.igen"
  TRACE_ALU_INPUT4 (GPR[rt], GPR[rs], lsb, msb);
  if (lsb <= msb)
    GPR[rt] ^= (GPR[rt] ^ (GPR[rs] << (lsb + 32)))
      & MASK64 (msb + 32, lsb + 32);
  TRACE_ALU_RESULT1 (GPR[rt]);
}
#line 3147 "support.c"

INLINE_SUPPORT\
(void)
do_seb
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt)
{
#line 163 "mips3264r2.igen"
  TRACE_ALU_INPUT1 (GPR[rt]);
  GPR[rd] = EXTEND8 (GPR[rt]);
  TRACE_ALU_RESULT1 (GPR[rd]);
}
#line 3159 "support.c"

INLINE_SUPPORT\
(void)
do_seh
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt)
{
#line 170 "mips3264r2.igen"
  TRACE_ALU_INPUT1 (GPR[rt]);
  GPR[rd] = EXTEND16 (GPR[rt]);
  TRACE_ALU_RESULT1 (GPR[rd]);
}
#line 3171 "support.c"

INLINE_SUPPORT\
(void)
do_rdhwr
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rd)
{
#line 177 "mips3264r2.igen"
  // Return 0 for all hardware registers currently
  GPR[rt] = EXTEND32 (0);
  TRACE_ALU_RESULT1 (GPR[rt]);
}
#line 3183 "support.c"

INLINE_SUPPORT\
(void)
do_wsbh
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt)
{
#line 184 "mips3264r2.igen"
  union { unsigned32 w; unsigned16 h[2]; } u;
  TRACE_ALU_INPUT1 (GPR[rt]);
  u.w = GPR[rt];
  u.h[0] = SWAP_2 (u.h[0]);
  u.h[1] = SWAP_2 (u.h[1]);
  GPR[rd] = EXTEND32 (u.w);
  TRACE_ALU_RESULT1 (GPR[rd]);
}
#line 3199 "support.c"

INLINE_SUPPORT\
(address_word)
delayslot16
(SIM_DESC sd, instruction_address cia, int MY_INDEX, address_word nia, address_word target)
{
#line 1037 "m16.igen"
  instruction_word delay_insn;
  sim_events_slip (SD, 1);
  DSPC = CIA; /* save current PC somewhere */
  STATE |= simDELAYSLOT;
  delay_insn = IMEM16 (nia); /* NOTE: mips16 */
  idecode_issue (CPU_, delay_insn, (nia));
  STATE &= ~simDELAYSLOT;
  return target;
}
#line 3216 "support.c"

INLINE_SUPPORT\
(address_word)
basepc
(SIM_DESC sd, instruction_address cia, int MY_INDEX)
{
#line 1050 "m16.igen"
  if (STATE & simDELAYSLOT)
    {
      return DSPC; /* return saved address of preceeding jmp */
    }
  else
    {
      return CIA;
    }
}
#line 3233 "support.c"

INLINE_SUPPORT\
(void)
do_save
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int xsregs, int aregs, int ras0s1, int framesize)
{
#line 171 "m16e.igen"
  unsigned_word temp;    
  int args, astatic;

  temp = GPR[29];

  /* writes are in the same order as the hardware description... */
  switch (aregs) {
  case 0: case 1: case 2: case 3: case 11:
    args = 0;
    break;
  case 4: case 5: case 6: case 7:
    args = 1;
    break;
  case 8: case 9: case 10:
    args = 2;
    break;
  case 12: case 13:
    args = 3;
    break;
  case 14:
    args = 4;
    break;
  default:
    sim_engine_abort (SD, CPU, CIA, "save: aregs=%d causes unpredictable results\n", aregs);
  }
  if (args > 0) {
    do_store (SD_, AccessLength_WORD, temp, 0, GPR[4]); 
    if (args > 1) {
      do_store (SD_,AccessLength_WORD, temp, 4 , GPR[5]); 
      if (args > 2) {
  	do_store (SD_,AccessLength_WORD, temp, 8 , GPR[6]); 
  	if (args > 3) {
  	  do_store (SD_,AccessLength_WORD, temp, 12, GPR[7]);
  	}
      }
    }
  }

  if (ras0s1 & 4)
    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[31]); 

  switch (xsregs) {
  case 7:
    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[30]); 
  case 6:
    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[23]); 
  case 5:
    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[22]); 
  case 4:
    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[21]); 
  case 3:
    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[20]); 
  case 2:
    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[19]); 
  case 1:
    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[18]); 
  }

  if (ras0s1 & 1)
    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[17]); 
  if (ras0s1 & 2)
    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[16]); 

  switch (aregs) {
  case 0: case 4: case 8: case 12: case 14:
    astatic = 0;
    break;
  case 1: case 5: case 9: case 13:
    astatic = 1;
    break;
  case 2: case 6: case 10:
    astatic = 2;
    break;
  case 3: case 7:
    astatic = 3;
    break;
  case 11:
    astatic = 4;
    break;
  default:
    sim_engine_abort (SD, CPU, CIA, "save: aregs=%d causes unpredictable results\n", aregs);
  }
  if (astatic > 0) {
    do_store (SD_, AccessLength_WORD, temp -= 4, 0, GPR[7]);
    if (astatic > 1) {
      do_store (SD_, AccessLength_WORD, temp -= 4, 0, GPR[6]);
      if (astatic > 2) {
  	do_store (SD_, AccessLength_WORD, temp -= 4, 0, GPR[5]);
  	if (astatic > 3) {
  	  do_store (SD_, AccessLength_WORD, temp -= 4, 0, GPR[4]);
  	}
      }
    }
  }

  GPR[29] -= framesize;
}
#line 3338 "support.c"

INLINE_SUPPORT\
(const char *)
str_MFHI
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int hi)
{
#line 8 "vr.igen"
  return hi ? "hi" : "";
}
#line 3348 "support.c"

INLINE_SUPPORT\
(const char *)
str_SAT
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int s)
{
#line 13 "vr.igen"
  return s ? "s" : "";
}
#line 3358 "support.c"

INLINE_SUPPORT\
(const char *)
str_UNS
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int u)
{
#line 18 "vr.igen"
  return u ? "u" : "";
}
#line 3368 "support.c"

INLINE_SUPPORT\
(void)
do_vr_mul_op
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int accumulate_p, int store_hi_p, int unsigned_p, int saturate_p, int subtract_p, int short_p, int double_p)
{
#line 43 "vr.igen"
  unsigned64 lhs, x, y, xcut, ycut, product, result;

  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);

  lhs = (!accumulate_p ? 0 : double_p ? LO : U8_4 (HI, LO));
  x = GPR[rs];
  y = GPR[rt];

  /* Work out the canonical form of X and Y from their significant bits.  */
  if (!short_p)
    {
      /* Normal sign-extension rule for 32-bit operands.  */
      xcut = EXTEND32 (x);
      ycut = EXTEND32 (y);
    }
  else if (unsigned_p)
    {
      /* Operands must be zero-extended 16-bit numbers.  */
      xcut = x & 0xffff;
      ycut = y & 0xffff;
    }
  else
    {
      /* Likewise but sign-extended.  */
      xcut = EXTEND16 (x);
      ycut = EXTEND16 (y);
    }
  if (x != xcut || y != ycut)
    sim_engine_abort (SD, CPU, CIA,
  		      "invalid multiplication operand at 0x%08lx\n",
  		      (long) CIA);

  TRACE_ALU_INPUT2 (x, y);
  product = (unsigned_p
  	     ? V8_4 (x, 1) * V8_4 (y, 1)
  	     : EXTEND32 (x) * EXTEND32 (y));
  result = (subtract_p ? lhs - product : lhs + product);
  if (saturate_p)
    {
      /* Saturate the result to 32 bits.  An unsigned, unsaturated
  	 result is zero-extended to 64 bits, but unsigned overflow
  	 causes all 64 bits to be set.  */
      if (!unsigned_p && (unsigned64) EXTEND32 (result) != result)
  	result = ((signed64) result < 0 ? -0x7fffffff - 1 : 0x7fffffff);
      else if (unsigned_p && (result >> 32) != 0)
  	result = (unsigned64) 0 - 1;
    }
  TRACE_ALU_RESULT (result);

  if (double_p)
    LO = result;
  else
    {
      LO = EXTEND32 (result);
      HI = EXTEND32 (VH4_8 (result));
    }
  if (rd != 0)
    GPR[rd] = store_hi_p ? HI : LO;
}
#line 3435 "support.c"

INLINE_SUPPORT\
(void)
do_ph_op
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int op, int sat)
{
#line 27 "dsp.igen"
  int i;
  signed32 h0 = 0;
  signed16 h1, h2;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned32 result = 0;
  for (i = 0; i < 32; i += 16, v1 >>= 16, v2 >>= 16)
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)(v2 & 0xffff);
      if (op == 0) // ADD
  	h0 = (signed32)h1 + (signed32)h2;
      else if (op == 1) // SUB
        h0 = (signed32)h1 - (signed32)h2;
      else // MUL
        h0 = (signed32)h1 * (signed32)h2;
      if (h0 > (signed32)0x7fff || h0 < (signed32)0xffff8000)
  	{
  	  if (op == 0 || op == 1) // ADD, SUB
  	    DSPCR |= DSPCR_OUFLAG4;
  	  else if (op == 2) // MUL
  	    DSPCR |= DSPCR_OUFLAG5;
  	  if (sat == 1)
  	    {
  	      if (h0 > (signed32)0x7fff)
  		h0 = 0x7fff;
  	      else
  		h0 = 0x8000;
  	    }
  	}
      result |= ((unsigned32)((unsigned16)h0) << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 3477 "support.c"

INLINE_SUPPORT\
(void)
do_w_op
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int op)
{
#line 65 "dsp.igen"
  signed64 h0;
  signed32 h1, h2;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned32 result = 0;
  h1 = (signed32)v1;
  h2 = (signed32)v2;
  if (op == 0) // ADD
    h0 = (signed64)h1 + (signed64)h2;
  else // SUB
    h0 = (signed64)h1 - (signed64)h2;
  if (((h0 & 0x100000000LL) >> 1) != (h0 & 0x80000000))
    {
      DSPCR |= DSPCR_OUFLAG4;
      if (h0 & 0x100000000LL)
  	h0 = 0x80000000;
      else
  	h0 = 0x7fffffff;
    }
  GPR[rd] = EXTEND32 (h0);
}
#line 3506 "support.c"

INLINE_SUPPORT\
(void)
do_qb_op
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int op, int sat)
{
#line 91 "dsp.igen"
  int i;
  unsigned32 h0;
  unsigned8 h1, h2;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned32 result = 0;
  for (i = 0; i < 32; i += 8, v1 >>= 8, v2 >>= 8)
    {
      h1 = (unsigned8)(v1 & 0xff);
      h2 = (unsigned8)(v2 & 0xff);
      if (op == 0) // ADD
  	h0 = (unsigned32)h1 + (unsigned32)h2;
      else // SUB
  	h0 = (unsigned32)h1 - (unsigned32)h2;
      if (h0 & 0x100)
  	{
  	  DSPCR |= DSPCR_OUFLAG4;
  	  if (sat == 1)
  	    {
  	      if (op == 0) // ADD
  		h0 = 0xff;
  	      else // SUB
  		h0 = 0;
  	    }
  	}
      result |= ((unsigned32)((unsigned8)h0) << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 3543 "support.c"

INLINE_SUPPORT\
(void)
do_qb_shift
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int shift, int op)
{
#line 124 "dsp.igen"
  int i, j;
  unsigned8 h0;
  unsigned32 v1 = GPR[rt];
  unsigned32 result = 0;
  for (i = 0; i < 32; i += 8, v1 >>= 8)
    {
      h0 = (unsigned8)(v1 & 0xff);
      if (op == 0) // left
  	{
  	  for (j = 7; j >= 8 - shift; j--)
  	    {
  	      if (h0 & (1<<j))
  		{
  		  DSPCR |= DSPCR_OUFLAG6;
  		  break;
  		}
  	    }
          h0 = h0 << shift;
  	}
      else // right
        h0 = h0 >> shift;
      result |= ((unsigned32)h0 << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 3576 "support.c"

INLINE_SUPPORT\
(void)
do_ph_shift
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int shift, int op, int sat)
{
#line 154 "dsp.igen"
  int i, j;
  signed16 h0;
  unsigned32 v1 = GPR[rt];
  unsigned32 result = 0;
  int setcond;
  for (i = 0; i < 32; i += 16, v1 >>= 16)
    {
      h0 = (signed16)(v1 & 0xffff);
      if (op == 0) // left
  	{
  	  setcond = 0;
  	  if (h0 & (1<<15))
  	    {
  	      for (j = 14; j >= 15 - shift; j--)
  		{
  		  if (!(h0 & (1 << j)))
  		    {
  		      DSPCR |= DSPCR_OUFLAG6;
  		      setcond = 1;
  		      break;
  		    }
  		}
  	    }
  	  else
  	    {
  	      for (j = 14; j >= 15 - shift; j--)
  		{
  		  if (h0 & (1 << j))
  		    {
  		      DSPCR |= DSPCR_OUFLAG6;
  		      setcond = 2;
  		      break;
  		    }
  		}
  	    }
  	  h0 = h0 << shift;
  	  if (sat == 1)
  	    {
  	      if (setcond == 2)
  		h0 = 0x7fff; 
  	      else if (setcond == 1)
  		h0 = 0x8000;
  	    }
  	}
      else // right
  	{
  	  if (sat == 1 && shift != 0 && (h0 & (1 << (shift-1))))
  	    h0 = (h0 >> shift) + 1;
  	  else
  	    h0 = h0 >> shift;
  	}

      result |= ((unsigned32)((unsigned16)h0) << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 3640 "support.c"

INLINE_SUPPORT\
(void)
do_w_shll
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int shift)
{
#line 213 "dsp.igen"
  int i;
  unsigned32 v1 = GPR[rt];
  unsigned32 result = 0;
  int setcond = 0;
  if (v1 & (1 << 31))
    {
      for (i = 30; i >= 31 - shift; i--)
  	{
  	  if (!(v1 & (1 << i)))
  	    {
  	      DSPCR |= DSPCR_OUFLAG6;
  	      setcond = 1;
  	      break;
  	    }
  	}
    }
  else
    {
      for (i = 30; i >= 31 - shift; i--)
  	{
  	  if (v1 & (1 << i))
  	    {
  	      DSPCR |= DSPCR_OUFLAG6;
  	      setcond = 2;
  	      break;
  	    }
  	}
    }
  if (setcond == 2)
    result = 0x7fffffff; 
  else if (setcond == 1)
    result = 0x80000000;
  else
    result = v1 << shift; 
  GPR[rd] = EXTEND32 (result);
}
#line 3684 "support.c"

INLINE_SUPPORT\
(void)
do_ph_s_absq
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt)
{
#line 252 "dsp.igen"
  int i;
  signed16 h0;
  unsigned32 v1 = GPR[rt];
  unsigned32 result = 0;
  for (i = 0; i < 32; i += 16, v1 >>= 16)
    {
      h0 = (signed16)(v1 & 0xffff);
      if (h0 == (signed16)0x8000)
  	{
  	  DSPCR |= DSPCR_OUFLAG4;
  	  h0 = 0x7fff;
  	}
      else if (h0 & 0x8000)
  	h0 = -h0;
      result |= ((unsigned32)((unsigned16)h0) << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 3710 "support.c"

INLINE_SUPPORT\
(void)
do_w_s_absq
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt)
{
#line 273 "dsp.igen"
  unsigned32 v1 = GPR[rt];
  signed32 h0 = (signed32)v1;
  if (h0 == (signed32)0x80000000)
    {
      DSPCR |= DSPCR_OUFLAG4;
      h0 = 0x7fffffff;
    }
  else if (h0 & 0x80000000)
    h0 = -h0;
  GPR[rd] = EXTEND32 (h0);
}
#line 3729 "support.c"

INLINE_SUPPORT\
(void)
do_qb_s_absq
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt)
{
#line 287 "dsp.igen"
  int i;
  signed8 q0;
  unsigned32 v1 = GPR[rt];
  unsigned32 result = 0;
  for (i = 0; i < 32; i += 8, v1 >>= 8)
    {
      q0 = (signed8)(v1 & 0xff);
      if (q0 == (signed8)0x80)
  	{
  	  DSPCR |= DSPCR_OUFLAG4;
  	  q0 = 0x7f;
  	}
      else if (q0 & 0x80)
  	q0 = -q0;
      result |= ((unsigned32)((unsigned8)q0) << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 3755 "support.c"

INLINE_SUPPORT\
(void)
do_addsc
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt)
{
#line 308 "dsp.igen"
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned64 h0;
  h0 = (unsigned64)v1 + (unsigned64)v2;
  if (h0 & 0x100000000LL)
    DSPCR |= DSPCR_CARRY;
  GPR[rd] = EXTEND32 (h0);
}
#line 3771 "support.c"

INLINE_SUPPORT\
(void)
do_addwc
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt)
{
#line 319 "dsp.igen"
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned64 h0;
  signed32 h1 = (signed32) v1;
  signed32 h2 = (signed32) v2;
  h0 = (signed64)h1 + (signed64)h2
    + (signed64)((DSPCR >> DSPCR_CARRY_SHIFT) & DSPCR_CARRY_MASK);
  if (((h0 & 0x100000000LL) >> 1) != (h0 & 0x80000000))
    DSPCR |= DSPCR_OUFLAG4;
  GPR[rd] = EXTEND32 (h0);
}
#line 3790 "support.c"

INLINE_SUPPORT\
(void)
do_bitrev
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt)
{
#line 333 "dsp.igen"
  int i;
  unsigned32 v1 = GPR[rt];
  unsigned32 h1 = 0;
  for (i = 0; i < 16; i++)
    {
      if (v1 & (1 << i))
  	h1 |= (1 << (15 - i));
    }
  GPR[rd] = EXTEND32 (h1);
}
#line 3808 "support.c"

INLINE_SUPPORT\
(void)
do_extpv
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int ac, int rs, int op)
{
#line 347 "dsp.igen"
  unsigned32 size = GPR[rs] & 0x1f;
  do_extp (SD_, rt, ac, size, op);
}
#line 3819 "support.c"

INLINE_SUPPORT\
(void)
do_extrv
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int ac, int rs, int op)
{
#line 354 "dsp.igen"
  unsigned32 shift = GPR[rs] & 0x1f;
  do_w_extr (SD_, rt, ac, shift, op);
}
#line 3830 "support.c"

INLINE_SUPPORT\
(void)
do_extrv_s_h
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int ac, int rs)
{
#line 360 "dsp.igen"
  unsigned32 shift = GPR[rs] & 0x1f;
  do_h_extr (SD_, rt, ac, shift);
}
#line 3841 "support.c"

INLINE_SUPPORT\
(void)
do_insv
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rs)
{
#line 366 "dsp.igen"
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned32 pos = (DSPCR >> DSPCR_POS_SHIFT) & DSPCR_POS_MASK;
  unsigned32 size = (DSPCR >> DSPCR_SCOUNT_SHIFT) & DSPCR_SCOUNT_MASK;
  unsigned32 mask1, mask2, mask3, result;
  if (size < 32)
    mask1 = (1 << size) - 1;
  else
    mask1 = 0xffffffff;
  mask2 = (1 << pos) - 1;
  if (pos + size < 32)
    mask3 = ~((1 << (pos + size)) - 1);
  else
    mask3 = 0;
  result = (v2 & mask3) | ((v1 & mask1) << pos) | (v2 & mask2);
  GPR[rt] = EXTEND32 (result);
}
#line 3866 "support.c"

INLINE_SUPPORT\
(void)
do_lxx
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int base, int index, int op)
{
#line 387 "dsp.igen"
  if (op == 0)
    GPR[rd] = do_load (SD_, AccessLength_BYTE, GPR[base], GPR[index]);
  else if (op == 1)
    GPR[rd] = EXTEND16 (do_load (SD_, AccessLength_HALFWORD, GPR[base], GPR[index]));
  else if (op == 2)
    GPR[rd] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[base], GPR[index]));
}
#line 3881 "support.c"

INLINE_SUPPORT\
(void)
do_modsub
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt)
{
#line 397 "dsp.igen"
  unsigned32 result = 0;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned32 decr = v2 & 0xff;
  unsigned32 lastindex = (v2 & 0xffff00) >> 8;
  if (v1 == 0)
    result = lastindex;
  else
    result =  v1 - decr;
  GPR[rd] = EXTEND32 (result);
}
#line 3900 "support.c"

INLINE_SUPPORT\
(void)
do_mthlip
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int ac)
{
#line 411 "dsp.igen"
  unsigned32 pos = (DSPCR >> DSPCR_POS_SHIFT) & DSPCR_POS_MASK;
  DSPHI(ac) = DSPLO(ac);
  DSPLO(ac) = GPR[rs];
  if (pos >= 32)
    Unpredictable ();
  else
    pos += 32;
  DSPCR &= (~DSPCR_POS_SMASK);
  DSPCR |= (pos & DSPCR_POS_MASK) << DSPCR_POS_SHIFT;
}
#line 3918 "support.c"

INLINE_SUPPORT\
(void)
do_mulsaq_s_w_ph
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs, int rt)
{
#line 424 "dsp.igen"
  int i;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed16 h1, h2;
  signed32 result;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  signed64 prod = (signed64)((((unsigned64)hi) << 32) + (unsigned64)lo);
  for (i = 0; i < 32; i += 16, v1 >>= 16, v2 >>= 16)
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)(v2 & 0xffff);
      if (h1 == (signed16)0x8000 && h2 == (signed16)0x8000)
  	{
  	  DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));
  	  result = (signed32) 0x7fffffff;
  	}
      else
  	result = ((signed32)h1 * (signed32)h2) << 1;

      if (i == 0)
  	prod -= (signed64) result;
      else
  	prod += (signed64) result;
    }
  DSPLO(ac) = EXTEND32 (prod);
  DSPHI(ac) = EXTEND32 (prod >> 32);
}
#line 3954 "support.c"

INLINE_SUPPORT\
(void)
do_ph_packrl
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt)
{
#line 455 "dsp.igen"

  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  GPR[rd] = EXTEND32 ((v1 << 16) + (v2 >> 16));
}
#line 3967 "support.c"

INLINE_SUPPORT\
(void)
do_qb_pick
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt)
{
#line 463 "dsp.igen"
  int i, j;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned8 h1, h2;
  unsigned32 result = 0;
  for (i = 0, j = 0; i < 32; i += 8, j++, v1 >>= 8, v2 >>= 8)
    {
      h1 = (unsigned8)(v1 & 0xff);
      h2 = (unsigned8)(v2 & 0xff);
      if (DSPCR & (1 << (DSPCR_CCOND_SHIFT + j)))
  	result |= (unsigned32)(h1 << i);
      else
  	result |= (unsigned32)(h2 << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 3991 "support.c"

INLINE_SUPPORT\
(void)
do_ph_pick
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt)
{
#line 482 "dsp.igen"
  int i, j;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned16 h1, h2;
  unsigned32 result = 0;
  for (i = 0, j = 0; i < 32; i += 16, j++, v1 >>= 16, v2 >>= 16)
    {
      h1 = (unsigned16)(v1 & 0xffff);
      h2 = (unsigned16)(v2 & 0xffff);
      if (DSPCR & (1 << (DSPCR_CCOND_SHIFT + j)))
  	result |= (unsigned32)(h1 << i);
      else
  	result |= (unsigned32)(h2 << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 4015 "support.c"

INLINE_SUPPORT\
(void)
do_qb_ph_precequ
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int op)
{
#line 502 "dsp.igen"
  unsigned32 v1 = GPR[rt];
  if (op == 0)
    GPR[rd] = EXTEND32 ((v1 & 0xff00) << 15) | ((v1 & 0xff) << 7);
  else if (op == 1)
    GPR[rd] = EXTEND32 ((v1 & 0xff0000) << 7) | ((v1 & 0xff) << 7);
  else if (op == 2)
    GPR[rd] = EXTEND32 ((v1 & 0xff000000) >> 1) | ((v1 & 0xff0000) >> 9);
  else if (op == 3)
    GPR[rd] = EXTEND32 ((v1 & 0xff000000) >> 1) | ((v1 & 0xff00) >> 1);
}
#line 4033 "support.c"

INLINE_SUPPORT\
(void)
do_qb_ph_preceu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int op)
{
#line 516 "dsp.igen"
  unsigned32 v1 = GPR[rt];
  if (op == 0)
    GPR[rd] = EXTEND32 ((v1 & 0xff00) << 8) | (v1 & 0xff);
  else if (op == 1)
    GPR[rd] = EXTEND32 ((v1 & 0xff0000) | (v1 & 0xff));
  else if (op == 2)
    GPR[rd] = EXTEND32 ((v1 & 0xff000000) >> 8) | ((v1 & 0xff0000) >> 16);
  else if (op == 3)
    GPR[rd] = EXTEND32 ((v1 & 0xff000000) >> 8) | ((v1 & 0xff00) >> 8);
}
#line 4051 "support.c"

INLINE_SUPPORT\
(void)
do_w_preceq
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int op)
{
#line 530 "dsp.igen"
  unsigned32 v1 = GPR[rt];
  if (op == 0)
    GPR[rd] = EXTEND32 (v1 & 0xffff0000);
  else if (op == 1)
    GPR[rd] = EXTEND32 ((v1 & 0xffff) << 16);
}
#line 4065 "support.c"

INLINE_SUPPORT\
(void)
do_w_ph_precrq
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt)
{
#line 539 "dsp.igen"
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned32 tempu = (v1 & 0xffff0000) >> 16;
  unsigned32 tempv = (v2 & 0xffff0000) >> 16;
  GPR[rd] = EXTEND32 ((tempu << 16) | tempv);
}
#line 4079 "support.c"

INLINE_SUPPORT\
(void)
do_ph_qb_precrq
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int sat)
{
#line 549 "dsp.igen"
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned32 tempu = 0, tempv = 0, tempw = 0, tempx = 0;
  if (sat == 0)
    {
      tempu = (v1 & 0xff000000) >> 24;
      tempv = (v1 & 0xff00) >> 8;
      tempw = (v2 & 0xff000000) >> 24;
      tempx = (v2 & 0xff00) >> 8;
    }
  else if (sat == 1)
    {
      if (v1 & 0x80000000)
  	{
  	  DSPCR |= DSPCR_OUFLAG6;
  	  tempu = 0;
  	}
      else if (!(v1 & 0x80000000) && ((v1 >> 16) > (unsigned32)0x7f80))
  	{
  	  DSPCR |= DSPCR_OUFLAG6;
  	  tempu = 0xff;
  	}
      else
  	tempu = (v1 & 0x7f800000) >> 23;
      if (v1 & 0x8000)
  	{
  	  DSPCR |= DSPCR_OUFLAG6;
  	  tempv = 0;
  	}
      else if (!(v1 & 0x8000) && ((v1 & 0xffff) > (unsigned32)0x7f80))
  	{
  	  DSPCR |= DSPCR_OUFLAG6;
  	  tempv = 0xff;
  	}
      else
  	tempv = (v1 & 0x7f80) >> 7;
      if (v2 & 0x80000000)
  	{
  	  DSPCR |= DSPCR_OUFLAG6;
  	  tempw = 0;
  	}
      else if (!(v2 & 0x80000000) && ((v2 >> 16) > (unsigned32)0x7f80))
  	{
  	  DSPCR |= DSPCR_OUFLAG6;
  	  tempw = 0xff;
  	}
      else
  	tempw = (v2 & 0x7f800000) >> 23;
      if (v2 & 0x8000)
  	{
  	  DSPCR |= DSPCR_OUFLAG6;
  	  tempx = 0;
  	}
      else if (!(v2 & 0x8000) && ((v2 & 0xffff) > (unsigned32)0x7f80))
  	{
  	  DSPCR |= DSPCR_OUFLAG6;
  	  tempx = 0xff;
  	}
      else
  	tempx = (v2 & 0x7f80) >> 7;
    }
  GPR[rd] = EXTEND32 ((tempu << 24) | (tempv << 16) | (tempw << 8) | tempx);
}
#line 4150 "support.c"

INLINE_SUPPORT\
(void)
do_w_ph_rs_precrq
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt)
{
#line 615 "dsp.igen"
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed32 h1 = (signed32)v1;
  signed32 h2 = (signed32)v2;
  signed64 temp1 = (signed64)h1 + (signed64)0x8000;
  signed32 temp2;
  signed64 temp3 = (signed64)h2 + (signed64)0x8000;
  signed32 temp4;
  if (((temp1 & 0x100000000LL) >> 1) != (temp1 & 0x80000000))
    {
      DSPCR |= DSPCR_OUFLAG6;
      temp2 = 0x7fff;
    }
  else
    temp2 = (signed32)((temp1 & 0xffff0000) >> 16);
  if (((temp3 & 0x100000000LL) >> 1) != (temp3 & 0x80000000))
    {
      DSPCR |= DSPCR_OUFLAG6;
      temp4 = 0x7fff;
    }
  else
    temp4 = (signed32)((temp3 & 0xffff0000) >> 16);
  GPR[rd] = EXTEND32 ((temp2 << 16) | temp4);
}
#line 4182 "support.c"

INLINE_SUPPORT\
(void)
do_qb_w_raddu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs)
{
#line 642 "dsp.igen"
  int i;
  unsigned8 h0;
  unsigned32 v1 = GPR[rs];
  unsigned32 result = 0;
  for (i = 0; i < 32; i += 8, v1 >>= 8)
    {
      h0 = (unsigned8)(v1 & 0xff);
      result += (unsigned32)h0;
    }
  GPR[rd] = EXTEND32 (result);
}
#line 4201 "support.c"

INLINE_SUPPORT\
(void)
do_rddsp
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int mask)
{
#line 656 "dsp.igen"
  unsigned32 result = 0;
  if (mask & 0x1)
    {
      result &= (~DSPCR_POS_SMASK);
      result |= (DSPCR & DSPCR_POS_SMASK);
    }
  if (mask & 0x2)
    {
      result &= (~DSPCR_SCOUNT_SMASK);
      result |= (DSPCR & DSPCR_SCOUNT_SMASK);
    }
  if (mask & 0x4)
    {
      result &= (~DSPCR_CARRY_SMASK);
      result |= (DSPCR & DSPCR_CARRY_SMASK);
    }
  if (mask & 0x8)
    {
      result &= (~DSPCR_OUFLAG_SMASK);
      result |= (DSPCR & DSPCR_OUFLAG_SMASK);
    }
  if (mask & 0x10)
    {
      result &= (~DSPCR_CCOND_SMASK);
      result |= (DSPCR & DSPCR_CCOND_SMASK);
    }
  if (mask & 0x20)
    {
      result &= (~DSPCR_EFI_SMASK);
      result |= (DSPCR & DSPCR_EFI_SMASK);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 4242 "support.c"

INLINE_SUPPORT\
(void)
do_repl
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int p2, int op)
{
#line 693 "dsp.igen"
  if (op == 0)
    GPR[rd] = EXTEND32 ((p2 << 24) | (p2 << 16) | (p2 << 8) | p2);
  else if (op == 1)
    {
      unsigned32 v1 = GPR[p2] & 0xff;
      GPR[rd] = EXTEND32 ((v1 << 24) | (v1 << 16) | (v1 << 8) | v1);
    }
  else if (op == 2)
    {
      signed32 v1 = p2;
      if (v1 & 0x200)
  	v1 |= 0xfffffc00;
      GPR[rd] = EXTEND32 ((v1 << 16) | (v1 & 0xffff));
    }
  else if (op == 3)
    {
      unsigned32 v1 = GPR[p2];
      v1 = v1 & 0xffff;
      GPR[rd] = EXTEND32 ((v1 << 16) | v1);
    }
}
#line 4271 "support.c"

INLINE_SUPPORT\
(void)
do_shilov
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs)
{
#line 717 "dsp.igen"
  signed32 shift = GPR[rs] & 0x3f;
  do_shilo (SD_, ac, shift);
}
#line 4282 "support.c"

INLINE_SUPPORT\
(void)
do_ph_shl
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int rs, int op, int sat)
{
#line 725 "dsp.igen"
  unsigned32 shift = GPR[rs] & 0xf;
  do_ph_shift (SD_, rd, rt, shift, op, sat);
}
#line 4293 "support.c"

INLINE_SUPPORT\
(void)
do_qb_shl
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int rs, int op)
{
#line 732 "dsp.igen"
  unsigned32 shift = GPR[rs] & 0x7;
  do_qb_shift (SD_, rd, rt, shift, op);
}
#line 4304 "support.c"

INLINE_SUPPORT\
(void)
do_w_s_shllv
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int rs)
{
#line 738 "dsp.igen"
  unsigned32 shift = GPR[rs] & 0x1f;
  do_w_shll (SD_, rd, rt, shift);
}
#line 4315 "support.c"

INLINE_SUPPORT\
(void)
do_ph_shrlv
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int rs)
{
#line 744 "dsp.igen"
  unsigned32 shift = GPR[rs] & 0xf;
  do_ph_shrl (SD_, rd, rt, shift);
}
#line 4326 "support.c"

INLINE_SUPPORT\
(void)
do_w_r_shrav
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int rs)
{
#line 750 "dsp.igen"
  unsigned32 shift = GPR[rs] & 0x1f;
  do_w_shra (SD_, rd, rt, shift);
}
#line 4337 "support.c"

INLINE_SUPPORT\
(void)
do_wrdsp
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int mask)
{
#line 756 "dsp.igen"
  unsigned32 v1 = GPR[rs];
  if (mask & 0x1)
    {
      DSPCR &= (~DSPCR_POS_SMASK);
      DSPCR |= (v1 & DSPCR_POS_SMASK);
    }
  if (mask & 0x2)
    {
      DSPCR &= (~DSPCR_SCOUNT_SMASK);
      DSPCR |= (v1 & DSPCR_SCOUNT_SMASK);
    }
  if (mask & 0x4)
    {
      DSPCR &= (~DSPCR_CARRY_SMASK);
      DSPCR |= (v1 & DSPCR_CARRY_SMASK);
    }
  if (mask & 0x8)
    {
      DSPCR &= (~DSPCR_OUFLAG_SMASK);
      DSPCR |= (v1 & DSPCR_OUFLAG_SMASK);
    }
  if (mask & 0x10)
    {
      DSPCR &= (~DSPCR_CCOND_SMASK);
      DSPCR |= (v1 & DSPCR_CCOND_SMASK);
    }
  if (mask & 0x20)
    {
      DSPCR &= (~DSPCR_EFI_SMASK);
      DSPCR |= (v1 & DSPCR_EFI_SMASK);
    }
}
#line 4377 "support.c"

INLINE_SUPPORT\
(void)
do_qb_shrav
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int rs, int round)
{
#line 792 "dsp.igen"
  unsigned32 shift = GPR[rs] & 0x7;
  do_qb_shra (SD_, rd, rt, shift, round);
}
#line 4388 "support.c"

INLINE_SUPPORT\
(void)
do_append
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rs, int sa)
{
#line 798 "dsp.igen"
  unsigned32 v0 = GPR[rs];
  unsigned32 v1 = GPR[rt];
  unsigned32 result;
  unsigned32 mask = (1 << sa) - 1;
  result = (v1 << sa) | (v0 & mask);
  GPR[rt] = EXTEND32 (result);
}
#line 4403 "support.c"

INLINE_SUPPORT\
(void)
do_balign
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rs, int bp)
{
#line 808 "dsp.igen"
  unsigned32 v0 = GPR[rs];
  unsigned32 v1 = GPR[rt];
  unsigned32 result;
  if (bp == 0)
    result = v1;
  else
    result = (v1 << 8 * bp) | (v0 >> 8 * (4 - bp));
  GPR[rt] = EXTEND32 (result);
}
#line 4420 "support.c"

INLINE_SUPPORT\
(void)
do_ph_w_mulsa
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs, int rt)
{
#line 820 "dsp.igen"
  int i;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed16 h1, h2;
  signed32 result;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  signed64 prod = (signed64)((((unsigned64)hi) << 32) + (unsigned64)lo);
  for (i = 0; i < 32; i += 16, v1 >>= 16, v2 >>= 16)
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)(v2 & 0xffff);
      result = (signed32)h1 * (signed32)h2;

      if (i == 0)
  	prod -= (signed64) result;
      else
  	prod += (signed64) result;
    }
  DSPLO(ac) = EXTEND32 (prod);
  DSPHI(ac) = EXTEND32 (prod >> 32);
}
#line 4450 "support.c"

INLINE_SUPPORT\
(void)
do_ph_qb_precr
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt)
{
#line 845 "dsp.igen"
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned32 tempu = (v1 & 0xff0000) >> 16;
  unsigned32 tempv = (v1 & 0xff);
  unsigned32 tempw = (v2 & 0xff0000) >> 16;
  unsigned32 tempx = (v2 & 0xff);
  GPR[rd] = EXTEND32 ((tempu << 24) | (tempv << 16) | (tempw << 8) | tempx);
}
#line 4466 "support.c"

INLINE_SUPPORT\
(void)
do_prepend
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rs, int sa)
{
#line 856 "dsp.igen"
  unsigned32 v0 = GPR[rs];
  unsigned32 v1 = GPR[rt];
  unsigned32 result;
  if (sa == 0)
    result = v1;
  else
    result = (v0 << (32 - sa)) | (v1 >> sa);
  GPR[rt] = EXTEND32 (result);
}
#line 4483 "support.c"

INLINE_SUPPORT\
(void)
do_w_shra
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int shift)
{
#line 868 "dsp.igen"
  unsigned32 result = GPR[rt];
  signed32 h0 = (signed32)result;
  if (shift != 0 && (h0 & (1 << (shift-1))))
    h0 = (h0 >> shift) + 1;
  else
    h0 = h0 >> shift;
  GPR[rd] = EXTEND32 (h0);
}
#line 4499 "support.c"

INLINE_SUPPORT\
(void)
do_qb_muleu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int loc)
{
#line 1202 "dsp.igen"
  int i;
  unsigned32 result = 0;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned16 h1, h2;
  unsigned32 prod;
  if (loc == 0)
    v1 >>= 16;
  for (i = 0; i < 32; i += 16, v1 >>= 8, v2 >>= 16)
    {
      h1 = (unsigned16)(v1 & 0xff);
      h2 = (unsigned16)(v2 & 0xffff);
      prod = (unsigned32)h1 * (unsigned32)h2;
      if (prod > 0xffff)
  	{
  	  DSPCR |= DSPCR_OUFLAG5;
  	  prod = 0xffff;
  	}
      result |= ((unsigned32)prod << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 4529 "support.c"

INLINE_SUPPORT\
(void)
do_ph_mulq
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int round)
{
#line 1242 "dsp.igen"
  int i;
  unsigned32 result = 0;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed16 h1, h2;
  signed32 prod;
  for (i = 0; i < 32; i += 16, v1 >>= 16, v2 >>= 16)
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)(v2 & 0xffff);
      if (h1 == (signed16)0x8000 && h2 == (signed16)0x8000)
  	{
  	  DSPCR |= DSPCR_OUFLAG5;
  	  prod = 0x7fffffff;
  	}
      else
  	{
  	  prod = ((signed32)h1 * (signed32)h2) << 1;
  	  if (round == 1)
  	    prod += (signed32)0x8000;
  	}
      result |= (((unsigned32)prod >> 16) << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 4562 "support.c"

INLINE_SUPPORT\
(void)
do_ph_muleq
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int loc)
{
#line 1278 "dsp.igen"
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed16 h1, h2;
  signed32 prod;
  if (loc == 0)
    {
      h1 = (signed16)(v1 >> 16);
      h2 = (signed16)(v2 >> 16);
    }
  else
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)(v2 & 0xffff);
    }
  if (h1 == (signed16)0x8000 && h2 == (signed16)0x8000)
    {
      DSPCR |= DSPCR_OUFLAG5;
      prod = 0x7fffffff;
    }
  else
    prod = ((signed32)h1 * (signed32)h2) << 1;
  GPR[rd] = EXTEND32 (prod);
}
#line 4593 "support.c"

INLINE_SUPPORT\
(void)
do_qb_dot_product
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs, int rt, int op, int loc)
{
#line 1320 "dsp.igen"
  int i;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned8 h1, h2;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  unsigned64 prod = (((unsigned64)hi) << 32) + (unsigned64)lo;
  if (loc == 0)
    {
      v1 >>= 16;
      v2 >>= 16;
    }
  for (i = 0; i < 16; i += 8, v1 >>= 8, v2 >>= 8)
    {
      h1 = (unsigned8)(v1 & 0xff);
      h2 = (unsigned8)(v2 & 0xff);
      if (op == 0) // DPAU
  	prod += (unsigned64)h1 * (unsigned64)h2;
      else // DPSU
  	prod -= (unsigned64)h1 * (unsigned64)h2;
    }
  DSPLO(ac) = EXTEND32 (prod);
  DSPHI(ac) = EXTEND32 (prod >> 32);
}
#line 4625 "support.c"

INLINE_SUPPORT\
(void)
do_ph_dot_product
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs, int rt, int op)
{
#line 1376 "dsp.igen"
  int i;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed16 h1, h2;
  signed32 result;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  signed64 prod = (signed64)((((unsigned64)hi) << 32) + (unsigned64)lo);
  for (i = 0; i < 32; i += 16, v1 >>= 16, v2 >>= 16)
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)(v2 & 0xffff);
      if (h1 == (signed16)0x8000 && h2 == (signed16)0x8000)
  	{
  	  DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));
  	  result = (signed32)0x7fffffff;
  	}
      else
  	result = ((signed32)h1 * (signed32)h2) << 1;

      if (op == 0) // DPAQ
  	prod += (signed64)result;
      else // DPSQ
  	prod -= (signed64)result;
    }
  DSPLO(ac) = EXTEND32 (prod);
  DSPHI(ac) = EXTEND32 (prod >> 32);
}
#line 4661 "support.c"

INLINE_SUPPORT\
(void)
do_w_dot_product
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs, int rt, int op)
{
#line 1429 "dsp.igen"
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed32 h1, h2;
  signed64 result;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  unsigned32 resultlo;
  unsigned32 resulthi;
  unsigned32 carry;
  unsigned64 temp1;
  signed64 temp2;
  h1 = (signed32) v1;
  h2 = (signed32) v2;
  if (h1 == 0x80000000 && h2 == 0x80000000)
    {
      DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));
      result = (signed64) 0x7fffffffffffffffLL;
    }
  else
    result = ((signed64)h1 * (signed64)h2) << 1;
  resultlo = (unsigned32)(result);
  resulthi = (unsigned32)(result >> 32);
  if (op ==0) // DPAQ
    {
      temp1 = (unsigned64)lo + (unsigned64)resultlo;
      carry = (unsigned32)((temp1 >> 32) & 1);
      temp2 = (signed64)((signed32)hi) + (signed64)((signed32)resulthi) +
  	      (signed64)((signed32)carry);
    }
  else // DPSQ
    {
      temp1 = (unsigned64)lo - (unsigned64)resultlo;
      carry = (unsigned32)((temp1 >> 32) & 1);
      temp2 = (signed64)((signed32)hi) - (signed64)((signed32)resulthi) -
  	      (signed64)((signed32)carry);
    }
  if (((temp2 & 0x100000000LL) >> 1) != (temp2 & 0x80000000LL))
    {
      DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));
      if (temp2 & 0x100000000LL)
  	{
  	  DSPLO(ac) = EXTEND32 (0x00000000);
  	  DSPHI(ac) = EXTEND32 (0x80000000);
  	}
      else
  	{
  	  DSPLO(ac) = EXTEND32 (0xffffffff);
  	  DSPHI(ac) = EXTEND32 (0x7fffffff);
  	}
    }
  else
    {
      DSPLO(ac) = EXTEND32 (temp1);
      DSPHI(ac) = EXTEND32 (temp2);
    }
}
#line 4725 "support.c"

INLINE_SUPPORT\
(void)
do_ph_maq
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs, int rt, int op, int loc)
{
#line 1504 "dsp.igen"
  int i;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed16 h1, h2;
  signed32 result;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  signed64 prod = (signed64)((((unsigned64)hi) << 32) + (unsigned64)lo);
  if (loc == 0)
    {
      h1 = (signed16)(v1 >> 16);
      h2 = (signed16)(v2 >> 16);
    }
  else
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)(v2 & 0xffff);
    }
  if (h1 == (signed16)0x8000 && h2 == (signed16)0x8000)
    {
      DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));
      result = (signed32)0x7fffffff;
    }
  else
    result = ((signed32)h1 * (signed32)h2) << 1;
  prod += (signed64)result;
  if (op == 1) // MAQ_SA
    {
      if (prod & 0x8000000000000000LL)
  	{
  	  for (i = 62; i >= 31; i--)
  	    {
  	      if (!(prod & ((signed64)1 << i)))
  		{
  		  DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));
  		  prod = 0xffffffff80000000LL;
  		  break;
  		}
  	    }
  	}
      else
  	{
  	  for (i = 62; i >= 31; i--)
  	    {
  	      if (prod & ((signed64)1 << i))
  		{
  		  DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));
  		  prod = 0x7fffffff;
  		  break;
  		}
  	    }
  	}
    }
  DSPLO(ac) = EXTEND32 (prod);
  DSPHI(ac) = EXTEND32 (prod >> 32);
}
#line 4789 "support.c"

INLINE_SUPPORT\
(void)
do_qb_cmpu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int op)
{
#line 1634 "dsp.igen"
  int i, j;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned8 h1, h2;
  unsigned32 mask;
  for (i = 0, j = 0; i < 32; i += 8, j++, v1 >>= 8, v2 >>= 8)
    {
      h1 = (unsigned8)(v1 & 0xff);
      h2 = (unsigned8)(v2 & 0xff);
      mask = ~(1 << (DSPCR_CCOND_SHIFT + j));
      DSPCR &= mask;
      if (op == 0) // EQ
  	DSPCR |= ((h1 == h2) << (DSPCR_CCOND_SHIFT + j));
      else if (op == 1) // LT
  	DSPCR |= ((h1 < h2) << (DSPCR_CCOND_SHIFT + j));
      else // LE
  	DSPCR |= ((h1 <= h2) << (DSPCR_CCOND_SHIFT + j));
    }
}
#line 4816 "support.c"

INLINE_SUPPORT\
(void)
do_qb_cmpgu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int op)
{
#line 1678 "dsp.igen"
  int i, j;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned8 h1, h2;
  unsigned32 result = 0;
  for (i = 0, j = 0; i < 32; i += 8, j++, v1 >>= 8, v2 >>= 8)
    {
      h1 = (unsigned8)(v1 & 0xff);
      h2 = (unsigned8)(v2 & 0xff);
      if (op == 0) // EQ
  	result |= ((h1 == h2) << j);
      else if (op == 1) // LT
  	result |= ((h1 < h2) << j);
      else // LE
  	result |= ((h1 <= h2) << j);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 4842 "support.c"

INLINE_SUPPORT\
(void)
do_ph_cmpu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int op)
{
#line 1721 "dsp.igen"
  int i, j;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed16 h1, h2;
  unsigned32 mask;
  for (i = 0, j = 0; i < 32; i += 16, j++, v1 >>= 16, v2 >>= 16)
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)(v2 & 0xffff);
      mask = ~(1 << (DSPCR_CCOND_SHIFT + j));
      DSPCR &= mask;
      if (op == 0) // EQ
  	DSPCR |= ((h1 == h2) << (DSPCR_CCOND_SHIFT + j));
      else if (op == 1) // LT
  	DSPCR |= ((h1 < h2) << (DSPCR_CCOND_SHIFT + j));
      else // LE
  	DSPCR |= ((h1 <= h2) << (DSPCR_CCOND_SHIFT + j));
    }
}
#line 4869 "support.c"

INLINE_SUPPORT\
(void)
do_w_extr
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int ac, int shift, int op)
{
#line 1786 "dsp.igen"
  int i;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  unsigned64 prod = (((unsigned64)hi) << 32) + (unsigned64)lo;
  signed64 result = (signed64)prod;
  int setcond = 0;
  if (!(prod & 0x8000000000000000LL))
    {
      for (i = 62; i >= (shift + 31); i--)
  	{
  	  if (prod & ((unsigned64)1 << i))
  	    {
  	      DSPCR |= DSPCR_OUFLAG7;
  	      setcond = 1;
  	      break;
  	    }
  	}
      if (((prod >> (shift - 1)) & 0xffffffffLL) == 0xffffffffLL)
  	{
  	  DSPCR |= DSPCR_OUFLAG7;
  	  setcond = 1;
  	}
    }
  else
    {
      for (i = 62; i >= (shift + 31); i--)
  	{
  	  if (!(prod & ((unsigned64)1 << i)))
  	    {
  	      DSPCR |= DSPCR_OUFLAG7;
  	      setcond = 2;
  	      break;
  	    }
  	}
    }
  if (op == 0) // EXTR
    result = result >> shift;
  else if (op == 1) // EXTR_R
    {
      if (shift != 0)
        result = ((result >> (shift - 1)) + 1) >> 1;
      else
  	result = result >> shift;
    }
  else // EXTR_RS
    {
      if (setcond == 1)
  	result = 0x7fffffff;
      else if (setcond == 2)
  	result = 0x80000000;
      else 
  	{
  	  if (shift != 0)
  	    result = ((result >> (shift - 1)) + 1) >> 1;
  	  else
  	    result = result >> shift;
  	}
    }
  GPR[rt] = EXTEND32 (result);
}
#line 4937 "support.c"

INLINE_SUPPORT\
(void)
do_h_extr
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int ac, int shift)
{
#line 1891 "dsp.igen"
  int i;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  unsigned64 prod = (((unsigned64)hi) << 32) + (unsigned64)lo;
  signed64 result = (signed64)prod;
  signed64 value = 0xffffffffffff8000LL;
  result >>= shift;
  if (result > 0x7fff)
    {
      result = 0x7fff;
      DSPCR |= DSPCR_OUFLAG7;
    }
  else if (result < value)
    {
      result = value;
      DSPCR |= DSPCR_OUFLAG7;
    }
  GPR[rt] = EXTEND32 (result);
}
#line 4964 "support.c"

INLINE_SUPPORT\
(void)
do_extp
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int ac, int size, int op)
{
#line 1928 "dsp.igen"
  signed32 pos = (DSPCR >> DSPCR_POS_SHIFT) & DSPCR_POS_MASK;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  unsigned64 prod = (((unsigned64)hi) << 32) + (unsigned64)lo;
  unsigned64 result = 0;
  if (pos - (size + 1) >= -1)
    {
      prod >>= (pos - size);
      result = prod & (((unsigned64)1 << (size + 1)) - 1);
      DSPCR &= (~DSPCR_EFI_SMASK);
      if (op == 1) // EXTPDP
  	{
  	  if (pos - (size + 1) >= 0)
  	    {
  	      DSPCR &= (~DSPCR_POS_SMASK);
  	      DSPCR |= ((pos - (size + 1)) & DSPCR_POS_MASK) << DSPCR_POS_SHIFT;
  	    }
  	  else if (pos - (size + 1) == -1)
  	    {
  	      DSPCR |= DSPCR_POS_SMASK;
  	    }
  	}
    }
  else
    {
      DSPCR |= DSPCR_EFI;
      Unpredictable ();
    }
  GPR[rt] = EXTEND32 (result);
}
#line 5002 "support.c"

INLINE_SUPPORT\
(void)
do_shilo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int shift)
{
#line 1989 "dsp.igen"
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  unsigned64 prod = (((unsigned64)hi) << 32) + (unsigned64)lo;
  if (shift > 31)
    shift = shift - 64;
  if (shift >= 0)
    prod >>= shift;
  else
    prod <<= (-shift);
  DSPLO(ac) = EXTEND32 (prod);
  DSPHI(ac) = EXTEND32 (prod >> 32);
}
#line 5022 "support.c"

INLINE_SUPPORT\
(void)
do_u_ph_op
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int op, int sat)
{
#line 28 "dsp2.igen"
  int i;
  unsigned32 h0;
  unsigned16 h1, h2;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned32 result = 0;
  for (i = 0; i < 32; i += 16, v1 >>= 16, v2 >>= 16)
    {
      h1 = (unsigned16)(v1 & 0xffff);
      h2 = (unsigned16)(v2 & 0xffff);
      if (op == 0) // ADD
  	h0 = (unsigned32)h1 + (unsigned32)h2;
      else // SUB
  	h0 = (unsigned32)h1 - (unsigned32)h2;
      if (op == 0 && (h0 > (unsigned32)0x0000ffff)) // ADD SAT
  	{
  	  DSPCR |= DSPCR_OUFLAG4;
  	  if (sat == 1)
  	    h0 = 0xffff;
  	}
      else if (op == 1 && h1 < h2) // SUB SAT
  	{
  	  DSPCR |= DSPCR_OUFLAG4;
  	  if (sat == 1)
  	    h0 = 0x0;
  	}
      result |= ((unsigned32)((unsigned16)h0) << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 5060 "support.c"

INLINE_SUPPORT\
(void)
do_uh_qb_op
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int op, int round)
{
#line 63 "dsp2.igen"
  int i;
  unsigned32 h0;
  unsigned8 h1, h2;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned32 result = 0;
  for (i = 0; i < 32; i += 8, v1 >>= 8, v2 >>= 8)
    {
      h1 = (unsigned8)(v1 & 0xff);
      h2 = (unsigned8)(v2 & 0xff);
      if (op == 0) // ADD
  	h0 = (unsigned32)h1 + (unsigned32)h2;
      else // SUB
  	h0 = (unsigned32)h1 - (unsigned32)h2;
      if (round == 1)
  	h0 = (h0 + 1) >> 1;
      else
  	h0 = h0 >> 1;
      result |= ((unsigned32)((unsigned8)h0) << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 5090 "support.c"

INLINE_SUPPORT\
(void)
do_qb_cmpgdu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int op)
{
#line 89 "dsp2.igen"
  int i, j;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned8 h1, h2;
  unsigned32 result = 0;
  unsigned32 mask;
  for (i = 0, j = 0; i < 32; i += 8, j++, v1 >>= 8, v2 >>= 8)
    {
      h1 = (unsigned8)(v1 & 0xff);
      h2 = (unsigned8)(v2 & 0xff);
      mask = ~(1 << (DSPCR_CCOND_SHIFT + j));
      DSPCR &= mask;
      if (op == 0) // EQ
  	{
  	  result |= ((h1 == h2) << j);
  	  DSPCR |= ((h1 == h2) << (DSPCR_CCOND_SHIFT + j));
  	}
      else if (op == 1) // LT
  	{
  	  result |= ((h1 < h2) << j);
  	  DSPCR |= ((h1 < h2) << (DSPCR_CCOND_SHIFT + j));
  	}
      else // LE
  	{
  	  result |= ((h1 <= h2) << j);
  	  DSPCR |= ((h1 <= h2) << (DSPCR_CCOND_SHIFT + j));
  	}
    }
  GPR[rd] = EXTEND32 (result);
}
#line 5128 "support.c"

INLINE_SUPPORT\
(void)
do_w_ph_dot_product
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs, int rt, int op)
{
#line 123 "dsp2.igen"
  int i;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed16 h1, h2;
  signed32 result;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  signed64 prod = (signed64)((((unsigned64)hi) << 32) + (unsigned64)lo);
  for (i = 0; i < 32; i += 16, v1 >>= 16, v2 >>= 16)
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)(v2 & 0xffff);
      result = (signed32)h1 * (signed32)h2;
      if (op == 0) // DPA
        prod += (signed64)result;
      else // DPS
        prod -= (signed64)result;
    }
  DSPLO(ac) = EXTEND32 (prod);
  DSPHI(ac) = EXTEND32 (prod >> 32);
}
#line 5157 "support.c"

INLINE_SUPPORT\
(void)
do_w_mulq
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int round)
{
#line 148 "dsp2.igen"
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed32 w1, w2;
  signed64 prod;
  unsigned32 result;
  w1 = (signed32) v1;
  w2 = (signed32 )v2;
  if (w1 == (signed32) 0x80000000 && w2 == (signed32) 0x80000000)
    {
      DSPCR |= DSPCR_OUFLAG5;
      prod = 0x7fffffff;
    }
  else
    {
      prod = ((signed64) w1 * (signed64) w2) << 1;
      if (round == 1)
  	prod += 0x0000000080000000LL;
      prod = prod >> 32;
    }
  result = (unsigned32) prod;
  GPR[rd] = EXTEND32 (result);
}
#line 5187 "support.c"

INLINE_SUPPORT\
(void)
do_precr_sra
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rs, int sa, int round)
{
#line 174 "dsp2.igen"
  unsigned32 v1 = GPR[rt];
  unsigned32 v2 = GPR[rs];
  signed32 w1 = (signed32) v1;
  signed32 w2 = (signed32) v2;
  signed32 result;
  if (sa != 0)
    {
      if (round == 1 && (w1 & (1 << (sa - 1))))
  	w1 = (w1 >> sa) + 1;
      else
  	w1 = w1 >> sa;

      if (round == 1 && (w2 & (1 << (sa - 1))))
  	w2 = (w2 >> sa) + 1;
      else
  	w2 = w2 >> sa;
    }
  result = (w1 << 16) | (w2 & 0xffff);
  GPR[rt] = EXTEND32 (result);
}
#line 5215 "support.c"

INLINE_SUPPORT\
(void)
do_qb_shra
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int shift, int round)
{
#line 198 "dsp2.igen"
  int i, j;
  signed8 q0;
  unsigned32 v1 = GPR[rt];
  unsigned32 result = 0;
  for (i = 0; i < 32; i += 8, v1 >>= 8)
    {
      q0 = (signed8)(v1 & 0xff);
      if (shift != 0)
   	{
  	  if (round == 1 && (q0 & (1 << (shift - 1))))
  	    q0 = (q0 >> shift) + 1;
  	  else
  	    q0 = q0 >> shift;
   	}
      result |= ((unsigned32)((unsigned8)q0) << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 5241 "support.c"

INLINE_SUPPORT\
(void)
do_ph_shrl
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rt, int shift)
{
#line 219 "dsp2.igen"
  int i, j;
  unsigned16 h0;
  unsigned32 v1 = GPR[rt];
  unsigned32 result = 0;
  for (i = 0; i < 32; i += 16, v1 >>= 16)
    {
      h0 = (unsigned16)(v1 & 0xffff);
      h0 = h0 >> shift;
      result |= ((unsigned32)h0 << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 5261 "support.c"

INLINE_SUPPORT\
(void)
do_qh_ph_op
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int op, int round)
{
#line 236 "dsp2.igen"
  int i;
  signed32 h0;
  signed16 h1, h2;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  unsigned32 result = 0;
  for (i = 0; i < 32; i += 16, v1 >>= 16, v2 >>= 16)
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)(v2 & 0xffff);
      if (op == 0) // ADD
  	h0 = (signed32)h1 + (signed32)h2;
      else // SUB
  	h0 = (signed32)h1 - (signed32)h2;
      if (round == 1)
  	h0 = (h0 + 1) >> 1;
      else
  	h0 = h0 >> 1;
      result |= ((unsigned32)((unsigned16)h0) << i);
    }
  GPR[rd] = EXTEND32 (result);
}
#line 5291 "support.c"

INLINE_SUPPORT\
(void)
do_qh_w_op
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int op, int round)
{
#line 263 "dsp2.igen"
  int i;
  signed64 v0;
  signed32 v1 = (signed32)GPR[rs];
  signed32 v2 = (signed32)GPR[rt];
  if (op == 0) // ADD
    v0 = (signed64)v1 + (signed64)v2;
  else // SUB
    v0 = (signed64)v1 - (signed64)v2;
  if (round == 1)
    v0 = (v0 + 1) >> 1;
  else
    v0 = v0 >> 1;
  GPR[rd] = EXTEND32 (v0);
}
#line 5313 "support.c"

INLINE_SUPPORT\
(void)
do_x_w_ph_dot_product
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs, int rt, int op)
{
#line 281 "dsp2.igen"
  int i;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed16 h1, h2;
  signed32 result;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  signed64 prod = (signed64)((((unsigned64)hi) << 32) + (unsigned64)lo);
  for (i = 0; i < 32; i += 16, v1 >>= 16, v2 <<= 16)
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)((v2 & 0xffff0000) >> 16);
      result = (signed32)h1 * (signed32)h2;
      if (op == 0) // DPAX
        prod += (signed64)result;
      else // DPSX
        prod -= (signed64)result;
    }
  DSPLO(ac) = EXTEND32 (prod);
  DSPHI(ac) = EXTEND32 (prod >> 32);
}
#line 5342 "support.c"

INLINE_SUPPORT\
(void)
do_qx_w_ph_dot_product
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int ac, int rs, int rt, int op, int sat)
{
#line 307 "dsp2.igen"
  int i;
  unsigned32 v1 = GPR[rs];
  unsigned32 v2 = GPR[rt];
  signed16 h1, h2;
  signed32 result;
  unsigned32 lo = DSPLO(ac);
  unsigned32 hi = DSPHI(ac);
  signed64 prod = (signed64)((((unsigned64)hi) << 32) + (unsigned64)lo);
  signed64 max, min;
  for (i = 0; i < 32; i += 16, v1 >>= 16, v2 <<= 16)
    {
      h1 = (signed16)(v1 & 0xffff);
      h2 = (signed16)((v2 & 0xffff0000) >> 16);
      if (h1 == (signed16)0x8000 && h2 == (signed16)0x8000)
  	{
  	  DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));
  	  result = 0x7fffffff;
  	}
      else
  	result = ((signed32)h1 * (signed32)h2) << 1;
      if (op == 0) // DPAQX
        prod += (signed64)result;
      else // DPSQX
        prod -= (signed64)result;
    }
  // Saturation on the accumulator.
  if (sat == 1)
    {
      max = (signed64) 0x7fffffffLL;
      min = (signed64) 0xffffffff80000000LL;
      if (prod > max)
  	{
  	  DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));
  	  prod = max;
  	}
      else if (prod < min)
  	{
  	  DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));
  	  prod = min;
  	}
    }
  DSPLO(ac) = EXTEND32 (prod);
  DSPHI(ac) = EXTEND32 (prod >> 32);
}
#line 5394 "support.c"


#endif /* _SUPPORT_C_*/
