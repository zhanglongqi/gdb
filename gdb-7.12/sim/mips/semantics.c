/* This file is part of GDB.

   Copyright 2002, 2007 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   --

   This file was generated by the program igen */

#ifndef SEMANTICS_C
#define SEMANTICS_C


#include "sim-inline.c"

#if C_REVEALS_MODULE_P (ITABLE_INLINE)
#include "itable.c"
#else
#include "itable.h"
#endif

#if C_REVEALS_MODULE_P (IDECODE_INLINE)
#include "idecode.c"
#else
#include "idecode.h"
#endif

#if C_REVEALS_MODULE_P (SUPPORT_INLINE)
#include "support.c"
#else
#include "support.h"
#endif

#include "semantics.h"


EXTERN_SEMANTICS\
(instruction_address)
semantic_SYSCALL_SPECIAL (SIM_DESC sd,
                          instruction_word instruction_0,
                          instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SYSCALL_SPECIAL
#undef SYSCALL_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SYSCALL_SPECIAL
#undef MY_NAME
#define MY_NAME "SYSCALL_SPECIAL"

  /* Extraction: SYSCALL
       #define do-not-use-icache
       6.0x0,20.CODE,6.0xc */

#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 25, 6)) /* cache - extraction */
#line 70 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,20.CODE,6.0xc */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4650 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "syscall %#lx", \
                    (unsigned long) CODE);
#line 87 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SYSCALL_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4664 "./mips.igen"
    SignalException (SystemCall, instruction_0);
  }
#line 115 "semantics.c"
  return nia;
  /* Extraction: SYSCALL
       #undef do-not-use-icache
       6.0x0,20.CODE,6.0xc */

#undef CODE
#line 122 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BREAK_SPECIAL (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BREAK_SPECIAL
#undef BREAK_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX BREAK_SPECIAL
#undef MY_NAME
#define MY_NAME "BREAK_SPECIAL"

  /* Extraction: BREAK
       #define do-not-use-icache
       6.0x0,20.CODE,6.0xd */

#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 25, 6)) /* cache - extraction */
#line 145 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,20.CODE,6.0xd */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2316 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "break %#lx", \
                    (unsigned long) CODE);
#line 162 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BREAK_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2330 "./mips.igen"
    do_break (SD_, instruction_0);
  }
#line 190 "semantics.c"
  return nia;
  /* Extraction: BREAK
       #undef do-not-use-icache
       6.0x0,20.CODE,6.0xd */

#undef CODE
#line 197 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TGE_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TGE_SPECIAL
#undef TGE_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TGE_SPECIAL
#undef MY_NAME
#define MY_NAME "TGE_SPECIAL"

  /* Extraction: TGE
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x30 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 232 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x30 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4703 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tge r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 250 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TGE_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4715 "./mips.igen"
    do_tge (SD_, RS, RT, instruction_0);
  }
#line 278 "semantics.c"
  return nia;
  /* Extraction: TGE
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x30 */

#undef RS
#undef RT
#undef CODE
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 291 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TGEU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TGEU_SPECIAL
#undef TGEU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TGEU_SPECIAL
#undef MY_NAME
#define MY_NAME "TGEU_SPECIAL"

  /* Extraction: TGEU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x31 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 326 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x31 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4754 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tgeu r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 344 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TGEU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4766 "./mips.igen"
    do_tgeu (SD_, RS, RT, instruction_0);
  }
#line 372 "semantics.c"
  return nia;
  /* Extraction: TGEU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x31 */

#undef RS
#undef RT
#undef CODE
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 385 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLT_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLT_SPECIAL
#undef TLT_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TLT_SPECIAL
#undef MY_NAME
#define MY_NAME "TLT_SPECIAL"

  /* Extraction: TLT
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x32 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 420 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x32 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4771 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlt r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 438 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLT_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4783 "./mips.igen"
    do_tlt (SD_, RS, RT, instruction_0);
  }
#line 466 "semantics.c"
  return nia;
  /* Extraction: TLT
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x32 */

#undef RS
#undef RT
#undef CODE
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 479 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLTU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLTU_SPECIAL
#undef TLTU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TLTU_SPECIAL
#undef MY_NAME
#define MY_NAME "TLTU_SPECIAL"

  /* Extraction: TLTU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x33 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 514 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x33 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4822 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tltu r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 532 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLTU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4834 "./mips.igen"
    do_tltu (SD_, RS, RT, instruction_0);
  }
#line 560 "semantics.c"
  return nia;
  /* Extraction: TLTU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x33 */

#undef RS
#undef RT
#undef CODE
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 573 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TEQ_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TEQ_SPECIAL
#undef TEQ_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TEQ_SPECIAL
#undef MY_NAME
#define MY_NAME "TEQ_SPECIAL"

  /* Extraction: TEQ
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x34 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 608 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x34 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4669 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "teq r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 626 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TEQ_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4681 "./mips.igen"
    do_teq (SD_, RS, RT, instruction_0);
  }
#line 654 "semantics.c"
  return nia;
  /* Extraction: TEQ
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x34 */

#undef RS
#undef RT
#undef CODE
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 667 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TNE_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TNE_SPECIAL
#undef TNE_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TNE_SPECIAL
#undef MY_NAME
#define MY_NAME "TNE_SPECIAL"

  /* Extraction: TNE
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x36 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 702 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x36 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4839 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tne r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 720 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TNE_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4851 "./mips.igen"
    do_tne (SD_, RS, RT, instruction_0);
  }
#line 748 "semantics.c"
  return nia;
  /* Extraction: TNE
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x36 */

#undef RS
#undef RT
#undef CODE
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 761 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_RSVD_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_RSVD_SPECIAL
#undef RSVD_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX RSVD_SPECIAL
#undef MY_NAME
#define MY_NAME "RSVD_SPECIAL"

  /* Extraction: RSVD
       #define do-not-use-icache
       6.0x0,5.*,5.*,5.*,5.OP,6.0x39 */

#undef OP
#define OP ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 784 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.*,5.*,5.*,5.OP,6.0x39 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 98 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "rsvd %ld", \
                    (long) OP);
#line 801 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_RSVD_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 100 "./mips.igen"
    SignalException (ReservedInstruction, instruction_0);
  }
#line 829 "semantics.c"
  return nia;
  /* Extraction: RSVD
       #undef do-not-use-icache
       6.0x0,5.*,5.*,5.*,5.OP,6.0x39 */

#undef OP
#line 836 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLLV_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLLV_SPECIAL
#undef SLLV_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SLLV_SPECIAL
#undef MY_NAME
#define MY_NAME "SLLV_SPECIAL"

  /* Extraction: SLLV
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x4 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef TRD
#define TRD ((int) ((RD < 2) ? (16 + RD) : RD)) /* scratch - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 873 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x4 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4264 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sllv r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) RS);
#line 897 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLLV_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4278 "./mips.igen"
    do_sllv (SD_, RS, RT, RD);
  }
#line 925 "semantics.c"
  return nia;
  /* Extraction: SLLV
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x4 */

#undef RS
#undef RT
#undef RD
#undef TRD
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 939 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SRLV_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SRLV_SPECIAL
#undef SRLV_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SRLV_SPECIAL
#undef MY_NAME
#define MY_NAME "SRLV_SPECIAL"

  /* Extraction: SRLV
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x6 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef TRD
#define TRD ((int) ((RD < 2) ? (16 + RD) : RD)) /* scratch - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 976 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x6 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4489 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "srlv r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) RS);
#line 1000 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SRLV_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4503 "./mips.igen"
    do_srlv (SD_, RS, RT, RD);
  }
#line 1028 "semantics.c"
  return nia;
  /* Extraction: SRLV
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x6 */

#undef RS
#undef RT
#undef RD
#undef TRD
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 1042 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SRAV_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SRAV_SPECIAL
#undef SRAV_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SRAV_SPECIAL
#undef MY_NAME
#define MY_NAME "SRAV_SPECIAL"

  /* Extraction: SRAV
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x7 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef TRD
#define TRD ((int) ((RD < 2) ? (16 + RD) : RD)) /* scratch - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 1079 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x7 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4429 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "srav r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) RS);
#line 1103 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SRAV_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4443 "./mips.igen"
    do_srav (SD_, RS, RT, RD);
  }
#line 1131 "semantics.c"
  return nia;
  /* Extraction: SRAV
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x7 */

#undef RS
#undef RT
#undef RD
#undef TRD
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 1145 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVZ_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVZ_SPECIAL
#undef MOVZ_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MOVZ_SPECIAL
#undef MY_NAME
#define MY_NAME "MOVZ_SPECIAL"

  /* Extraction: MOVZ
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xa */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef TRD
#define TRD ((int) ((RD < 2) ? (16 + RD) : RD)) /* scratch - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 1182 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xa */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3638 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "movz r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1206 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVZ_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3647 "./mips.igen"
    do_movz (SD_, RD, RS, RT);
  }
#line 1234 "semantics.c"
  return nia;
  /* Extraction: MOVZ
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xa */

#undef RS
#undef RT
#undef RD
#undef TRD
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 1248 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVN_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVN_SPECIAL
#undef MOVN_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MOVN_SPECIAL
#undef MY_NAME
#define MY_NAME "MOVN_SPECIAL"

  /* Extraction: MOVN
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xb */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef TRD
#define TRD ((int) ((RD < 2) ? (16 + RD) : RD)) /* scratch - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 1285 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xb */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3623 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "movn r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1309 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVN_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3632 "./mips.igen"
    do_movn (SD_, RD, RS, RT);
  }
#line 1337 "semantics.c"
  return nia;
  /* Extraction: MOVN
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xb */

#undef RS
#undef RT
#undef RD
#undef TRD
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 1351 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ADD_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ADD_SPECIAL
#undef ADD_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX ADD_SPECIAL
#undef MY_NAME
#define MY_NAME "ADD_SPECIAL"

  /* Extraction: ADD
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x20 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef TRD
#define TRD ((int) ((RD < 2) ? (16 + RD) : RD)) /* scratch - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 1388 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x20 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1757 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "add r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1412 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ADD_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1771 "./mips.igen"
    do_add (SD_, RS, RT, RD);
  }
#line 1440 "semantics.c"
  return nia;
  /* Extraction: ADD
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x20 */

#undef RS
#undef RT
#undef RD
#undef TRD
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 1454 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ADDU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ADDU_SPECIAL
#undef ADDU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX ADDU_SPECIAL
#undef MY_NAME
#define MY_NAME "ADDU_SPECIAL"

  /* Extraction: ADDU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x21 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef TRD
#define TRD ((int) ((RD < 2) ? (16 + RD) : RD)) /* scratch - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 1491 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x21 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1835 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "addu r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1515 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ADDU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1849 "./mips.igen"
    do_addu (SD_, RS, RT, RD);
  }
#line 1543 "semantics.c"
  return nia;
  /* Extraction: ADDU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x21 */

#undef RS
#undef RT
#undef RD
#undef TRD
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 1557 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SUB_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SUB_SPECIAL
#undef SUB_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SUB_SPECIAL
#undef MY_NAME
#define MY_NAME "SUB_SPECIAL"

  /* Extraction: SUB
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x22 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef TRD
#define TRD ((int) ((RD < 2) ? (16 + RD) : RD)) /* scratch - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 1594 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x22 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4508 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sub r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1618 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SUB_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4522 "./mips.igen"
    do_sub (SD_, RD, RS, RT);
  }
#line 1646 "semantics.c"
  return nia;
  /* Extraction: SUB
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x22 */

#undef RS
#undef RT
#undef RD
#undef TRD
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 1660 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SUBU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SUBU_SPECIAL
#undef SUBU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SUBU_SPECIAL
#undef MY_NAME
#define MY_NAME "SUBU_SPECIAL"

  /* Extraction: SUBU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x23 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef TRD
#define TRD ((int) ((RD < 2) ? (16 + RD) : RD)) /* scratch - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 1697 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x23 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4536 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "subu r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1721 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SUBU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4550 "./mips.igen"
    do_subu (SD_, RS, RT, RD);
  }
#line 1749 "semantics.c"
  return nia;
  /* Extraction: SUBU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x23 */

#undef RS
#undef RT
#undef RD
#undef TRD
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 1763 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_AND_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_AND_SPECIAL
#undef AND_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX AND_SPECIAL
#undef MY_NAME
#define MY_NAME "AND_SPECIAL"

  /* Extraction: AND
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x24 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef TRD
#define TRD ((int) ((RD < 2) ? (16 + RD) : RD)) /* scratch - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 1800 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x24 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1862 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "and r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1824 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_AND_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1876 "./mips.igen"
    do_and (SD_, RS, RT, RD);
  }
#line 1852 "semantics.c"
  return nia;
  /* Extraction: AND
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x24 */

#undef RS
#undef RT
#undef RD
#undef TRD
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 1866 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_OR_SPECIAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_OR_SPECIAL
#undef OR_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX OR_SPECIAL
#undef MY_NAME
#define MY_NAME "OR_SPECIAL"

  /* Extraction: OR
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x25 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef TRD
#define TRD ((int) ((RD < 2) ? (16 + RD) : RD)) /* scratch - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 1903 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x25 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3902 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "or r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1927 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_OR_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3916 "./mips.igen"
    do_or (SD_, RS, RT, RD);
  }
#line 1955 "semantics.c"
  return nia;
  /* Extraction: OR
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x25 */

#undef RS
#undef RT
#undef RD
#undef TRD
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 1969 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_XOR_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_XOR_SPECIAL
#undef XOR_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX XOR_SPECIAL
#undef MY_NAME
#define MY_NAME "XOR_SPECIAL"

  /* Extraction: XOR
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x26 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef TRD
#define TRD ((int) ((RD < 2) ? (16 + RD) : RD)) /* scratch - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 2006 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x26 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4880 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "xor r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 2030 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_XOR_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4894 "./mips.igen"
    do_xor (SD_, RS, RT, RD);
  }
#line 2058 "semantics.c"
  return nia;
  /* Extraction: XOR
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x26 */

#undef RS
#undef RT
#undef RD
#undef TRD
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 2072 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_NOR_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_NOR_SPECIAL
#undef NOR_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX NOR_SPECIAL
#undef MY_NAME
#define MY_NAME "NOR_SPECIAL"

  /* Extraction: NOR
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x27 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef TRD
#define TRD ((int) ((RD < 2) ? (16 + RD) : RD)) /* scratch - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 2109 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x27 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3876 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "nor r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 2133 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_NOR_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3890 "./mips.igen"
    do_nor (SD_, RS, RT, RD);
  }
#line 2161 "semantics.c"
  return nia;
  /* Extraction: NOR
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x27 */

#undef RS
#undef RT
#undef RD
#undef TRD
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 2175 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLT_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLT_SPECIAL
#undef SLT_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SLT_SPECIAL
#undef MY_NAME
#define MY_NAME "SLT_SPECIAL"

  /* Extraction: SLT
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2a */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef TRD
#define TRD ((int) ((RD < 2) ? (16 + RD) : RD)) /* scratch - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 2212 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2a */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4290 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "slt r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 2236 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLT_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4304 "./mips.igen"
    do_slt (SD_, RS, RT, RD);
  }
#line 2264 "semantics.c"
  return nia;
  /* Extraction: SLT
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2a */

#undef RS
#undef RT
#undef RD
#undef TRD
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 2278 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLTU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLTU_SPECIAL
#undef SLTU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SLTU_SPECIAL
#undef MY_NAME
#define MY_NAME "SLTU_SPECIAL"

  /* Extraction: SLTU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2b */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef TRD
#define TRD ((int) ((RD < 2) ? (16 + RD) : RD)) /* scratch - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 2315 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2b */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4369 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sltu r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 2339 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLTU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4383 "./mips.igen"
    do_sltu (SD_, RS, RT, RD);
  }
#line 2367 "semantics.c"
  return nia;
  /* Extraction: SLTU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2b */

#undef RS
#undef RT
#undef RD
#undef TRD
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 2381 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MULT_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MULT_SPECIAL
#undef MULT_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MULT_SPECIAL
#undef MY_NAME
#define MY_NAME "MULT_SPECIAL"

  /* Extraction: MULT
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x18 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 2414 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.0x0,6.0x18 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000ffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3781 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mult r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 2437 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MULT_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3791 "./mips.igen"
    do_mult (SD_, RS, RT, 0);
  }
#line 2465 "semantics.c"
  return nia;
  /* Extraction: MULT
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x18 */

#undef RS
#undef RT
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 2477 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MULTU_SPECIAL (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MULTU_SPECIAL
#undef MULTU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MULTU_SPECIAL
#undef MY_NAME
#define MY_NAME "MULTU_SPECIAL"

  /* Extraction: MULTU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x19 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 2510 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.0x0,6.0x19 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000ffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3833 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "multu r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 2533 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MULTU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3843 "./mips.igen"
    do_multu (SD_, RS, RT, 0);
  }
#line 2561 "semantics.c"
  return nia;
  /* Extraction: MULTU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x19 */

#undef RS
#undef RT
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 2573 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DIV_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DIV_SPECIAL
#undef DIV_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DIV_SPECIAL
#undef MY_NAME
#define MY_NAME "DIV_SPECIAL"

  /* Extraction: DIV
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1a */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 2606 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.0x0,6.0x1a */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000ffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2583 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "div r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 2629 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DIV_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2597 "./mips.igen"
    do_div (SD_, RS, RT);
  }
#line 2657 "semantics.c"
  return nia;
  /* Extraction: DIV
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1a */

#undef RS
#undef RT
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 2669 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DIVU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DIVU_SPECIAL
#undef DIVU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DIVU_SPECIAL
#undef MY_NAME
#define MY_NAME "DIVU_SPECIAL"

  /* Extraction: DIVU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1b */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 2702 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.0x0,6.0x1b */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000ffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2624 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "divu r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 2725 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DIVU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2638 "./mips.igen"
    do_divu (SD_, RS, RT);
  }
#line 2753 "semantics.c"
  return nia;
  /* Extraction: DIVU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1b */

#undef RS
#undef RT
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 2765 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVtf_SPECIAL (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVtf_SPECIAL
#undef MOVtf_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MOVtf_SPECIAL
#undef MY_NAME
#define MY_NAME "MOVtf_SPECIAL"

  /* Extraction: MOVtf
       #define do-not-use-icache
       6.0x0,5.RS,3.CC,1.0x0,1.TF,5.RD,5.0x0,6.0x1 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef CC
#define CC ((unsigned) EXTRACTED32 (instruction_0, 20, 18)) /* cache - extraction */
#undef TF
#define TF ((unsigned) EXTRACTED32 (instruction_0, 16, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef TRD
#define TRD ((int) ((RD < 2) ? (16 + RD) : RD)) /* scratch - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 2800 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,3.CC,1.0x0,1.TF,5.RD,5.0x0,6.0x1 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000207c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5771 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mov%s r%ld, r%ld, %ld", \
                    str_TF (SD_, TF), \
                    (long) RD, \
                    (long) RS, \
                    (long) CC);
#line 2839 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVtf_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5780 "./mips.igen"
    do_movtf (SD_, TF, RD, RS, CC);
  }
#line 2867 "semantics.c"
  return nia;
  /* Extraction: MOVtf
       #undef do-not-use-icache
       6.0x0,5.RS,3.CC,1.0x0,1.TF,5.RD,5.0x0,6.0x1 */

#undef RS
#undef CC
#undef TF
#undef RD
#undef TRD
#undef TRS
#undef ERS
#line 2880 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_JALR_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_JALR_SPECIAL
#undef JALR_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX JALR_SPECIAL
#undef MY_NAME
#define MY_NAME "JALR_SPECIAL"

  /* Extraction: JALR
       #define do-not-use-icache
       6.0x0,5.RS,5.0x0,5.RD,5.0x0,6.0x9 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef TRD
#define TRD ((int) ((RD < 2) ? (16 + RD) : RD)) /* scratch - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 2911 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.0x0,5.RD,5.0x0,6.0x9 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f07c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
      if (RD == 31)
#line 3064 "./mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "jalr r%ld", \
                      (long) RS);
#line 2934 "semantics.c"
      else
#line 3065 "./mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "jalr r%ld, r%ld", \
                      (long) RD, \
                      (long) RS);
#line 2943 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_JALR_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3079 "./mips.igen"
    address_word temp = GPR[RS];
    GPR[RD] = CIA + 8;
    DELAY_SLOT (temp);
  }
#line 2973 "semantics.c"
  return nia;
  /* Extraction: JALR
       #undef do-not-use-icache
       6.0x0,5.RS,5.0x0,5.RD,5.0x0,6.0x9 */

#undef RS
#undef RD
#undef TRD
#undef TRS
#undef ERS
#line 2984 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_JR_SPECIAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_JR_SPECIAL
#undef JR_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX JR_SPECIAL
#undef MY_NAME
#define MY_NAME "JR_SPECIAL"

  /* Extraction: JR
       #define do-not-use-icache
       6.0x0,5.RS,10.0x0,5.0x0,6.0x8 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 3011 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,10.0x0,5.0x0,6.0x8 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001fffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3096 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "jr r%ld", \
                    (long) RS);
#line 3033 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_JR_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3110 "./mips.igen"
    DELAY_SLOT (GPR[RS]);
  }
#line 3061 "semantics.c"
  return nia;
  /* Extraction: JR
       #undef do-not-use-icache
       6.0x0,5.RS,10.0x0,5.0x0,6.0x8 */

#undef RS
#undef TRS
#undef ERS
#line 3070 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MTHI_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MTHI_SPECIAL
#undef MTHI_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MTHI_SPECIAL
#undef MY_NAME
#define MY_NAME "MTHI_SPECIAL"

  /* Extraction: MTHI
       #define do-not-use-icache
       6.0x0,5.RS,15.0x0,6.0x11 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 3097 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,15.0x0,6.0x11 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001fffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3695 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mthi r%ld", \
                    (long) RS);
#line 3119 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MTHI_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3707 "./mips.igen"
    do_mthi (SD_, RS);
  }
#line 3147 "semantics.c"
  return nia;
  /* Extraction: MTHI
       #undef do-not-use-icache
       6.0x0,5.RS,15.0x0,6.0x11 */

#undef RS
#undef TRS
#undef ERS
#line 3156 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MTLO_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MTLO_SPECIAL
#undef MTLO_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MTLO_SPECIAL
#undef MY_NAME
#define MY_NAME "MTLO_SPECIAL"

  /* Extraction: MTLO
       #define do-not-use-icache
       6.0x0,5.RS,15.0x0,6.0x13 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 3183 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,15.0x0,6.0x13 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001fffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3723 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mtlo r%ld", \
                    (long) RS);
#line 3205 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MTLO_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3735 "./mips.igen"
    do_mtlo (SD_, RS);
  }
#line 3233 "semantics.c"
  return nia;
  /* Extraction: MTLO
       #undef do-not-use-icache
       6.0x0,5.RS,15.0x0,6.0x13 */

#undef RS
#undef TRS
#undef ERS
#line 3242 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLLa_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLLa_SPECIAL
#undef SLLa_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SLLa_SPECIAL
#undef MY_NAME
#define MY_NAME "SLLa_SPECIAL"

  /* Extraction: SLLa
       #define do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SHIFT
#define SHIFT ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef TRD
#define TRD ((int) ((RD < 2) ? (16 + RD) : RD)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef SHIFT_DEC
#define SHIFT_DEC ((int) ((SHIFT == 0) ? 8 : SHIFT)) /* scratch - extraction */
#line 3277 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
      if (RD == 0 && RT == 0 && SHIFT == 0)
#line 4221 "./mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "nop");
#line 3299 "semantics.c"
      else
#line 4222 "./mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "sll r%ld, r%ld, %ld", \
                      (long) RD, \
                      (long) RT, \
                      (long) SHIFT);
#line 3309 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLLa_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4232 "./mips.igen"
    /* Skip shift for NOP, so that there won't be lots of extraneous
       trace output.  */
    if (RD != 0 || RT != 0 || SHIFT != 0)
      do_sll (SD_, RT, RD, SHIFT);
  }
#line 3340 "semantics.c"
  return nia;
  /* Extraction: SLLa
       #undef do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x0 */

#undef RT
#undef RD
#undef SHIFT
#undef TRD
#undef TRT
#undef ERT
#undef SHIFT_DEC
#line 3353 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SRL_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SRL_SPECIAL
#undef SRL_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SRL_SPECIAL
#undef MY_NAME
#define MY_NAME "SRL_SPECIAL"

  /* Extraction: SRL
       #define do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x2 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SHIFT
#define SHIFT ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef TRD
#define TRD ((int) ((RD < 2) ? (16 + RD) : RD)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef SHIFT_DEC
#define SHIFT_DEC ((int) ((SHIFT == 0) ? 8 : SHIFT)) /* scratch - extraction */
#line 3388 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x2 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4459 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "srl r%ld, r%ld, %ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) SHIFT);
#line 3412 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SRL_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4473 "./mips.igen"
    do_srl (SD_, RT, RD, SHIFT);
  }
#line 3440 "semantics.c"
  return nia;
  /* Extraction: SRL
       #undef do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x2 */

#undef RT
#undef RD
#undef SHIFT
#undef TRD
#undef TRT
#undef ERT
#undef SHIFT_DEC
#line 3453 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SRA_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SRA_SPECIAL
#undef SRA_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SRA_SPECIAL
#undef MY_NAME
#define MY_NAME "SRA_SPECIAL"

  /* Extraction: SRA
       #define do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SHIFT
#define SHIFT ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef TRD
#define TRD ((int) ((RD < 2) ? (16 + RD) : RD)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef SHIFT_DEC
#define SHIFT_DEC ((int) ((SHIFT == 0) ? 8 : SHIFT)) /* scratch - extraction */
#line 3488 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4398 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sra r%ld, r%ld, %ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) SHIFT);
#line 3512 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SRA_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4412 "./mips.igen"
    do_sra (SD_, RT, RD, SHIFT);
  }
#line 3540 "semantics.c"
  return nia;
  /* Extraction: SRA
       #undef do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3 */

#undef RT
#undef RD
#undef SHIFT
#undef TRD
#undef TRT
#undef ERT
#undef SHIFT_DEC
#line 3553 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MFHI_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MFHI_SPECIAL
#undef MFHI_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MFHI_SPECIAL
#undef MY_NAME
#define MY_NAME "MFHI_SPECIAL"

  /* Extraction: MFHI
       #define do-not-use-icache
       6.0x0,10.0x0,5.RD,5.0x0,6.0x10 */

#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef TRD
#define TRD ((int) ((RD < 2) ? (16 + RD) : RD)) /* scratch - extraction */
#line 3578 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,10.0x0,5.RD,5.0x0,6.0x10 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03ff07c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3559 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mfhi r%ld", \
                    (long) RD);
#line 3600 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MFHI_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3571 "./mips.igen"
    do_mfhi (SD_, RD);
  }
#line 3628 "semantics.c"
  return nia;
  /* Extraction: MFHI
       #undef do-not-use-icache
       6.0x0,10.0x0,5.RD,5.0x0,6.0x10 */

#undef RD
#undef TRD
#line 3636 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MFLO_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MFLO_SPECIAL
#undef MFLO_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MFLO_SPECIAL
#undef MY_NAME
#define MY_NAME "MFLO_SPECIAL"

  /* Extraction: MFLO
       #define do-not-use-icache
       6.0x0,10.0x0,5.RD,5.0x0,6.0x12 */

#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef TRD
#define TRD ((int) ((RD < 2) ? (16 + RD) : RD)) /* scratch - extraction */
#line 3661 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,10.0x0,5.RD,5.0x0,6.0x12 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03ff07c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3595 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mflo r%ld", \
                    (long) RD);
#line 3683 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MFLO_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3607 "./mips.igen"
    do_mflo (SD_, RD);
  }
#line 3711 "semantics.c"
  return nia;
  /* Extraction: MFLO
       #undef do-not-use-icache
       6.0x0,10.0x0,5.RD,5.0x0,6.0x12 */

#undef RD
#undef TRD
#line 3719 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SYNC_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SYNC_SPECIAL
#undef SYNC_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SYNC_SPECIAL
#undef MY_NAME
#define MY_NAME "SYNC_SPECIAL"

  /* Extraction: SYNC
       #define do-not-use-icache
       6.0x0,15.0x0,5.STYPE,6.0xf */

#undef STYPE
#define STYPE ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 3742 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,15.0x0,5.STYPE,6.0xf */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03fff800) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
      if (STYPE == 0)
#line 4631 "./mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "sync");
#line 3764 "semantics.c"
      else
#line 4632 "./mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "sync %ld", \
                      (long) STYPE);
#line 3772 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SYNC_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4645 "./mips.igen"
    SyncOperation (STYPE);
  }
#line 3800 "semantics.c"
  return nia;
  /* Extraction: SYNC
       #undef do-not-use-icache
       6.0x0,15.0x0,5.STYPE,6.0xf */

#undef STYPE
#line 3807 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLTZ_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLTZ_REGIMM
#undef BLTZ_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BLTZ_REGIMM
#undef MY_NAME
#define MY_NAME "BLTZ_REGIMM"

  /* Extraction: BLTZ
       #define do-not-use-icache
       6.0x1,5.RS,5.0x0,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 3836 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x0,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2159 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bltz r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 3854 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLTZ_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2173 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] < 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 3886 "semantics.c"
  return nia;
  /* Extraction: BLTZ
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x0,16.OFFSET */

#undef RS
#undef OFFSET
#undef TRS
#undef ERS
#line 3896 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGEZ_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGEZ_REGIMM
#undef BGEZ_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BGEZ_REGIMM
#undef MY_NAME
#define MY_NAME "BGEZ_REGIMM"

  /* Extraction: BGEZ
       #define do-not-use-icache
       6.0x1,5.RS,5.0x1,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 3925 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x1,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1951 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgez r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 3943 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGEZ_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1965 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] >= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 3975 "semantics.c"
  return nia;
  /* Extraction: BGEZ
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x1,16.OFFSET */

#undef RS
#undef OFFSET
#undef TRS
#undef ERS
#line 3985 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLTZL_REGIMM (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLTZL_REGIMM
#undef BLTZL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BLTZL_REGIMM
#undef MY_NAME
#define MY_NAME "BLTZL_REGIMM"

  /* Extraction: BLTZL
       #define do-not-use-icache
       6.0x1,5.RS,5.0x2,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 4014 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x2,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2240 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bltzl r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 4032 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLTZL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2253 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    /* NOTE: The branch occurs AFTER the next instruction has been
       executed */
    if ((signed_word) GPR[RS] < 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 4068 "semantics.c"
  return nia;
  /* Extraction: BLTZL
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x2,16.OFFSET */

#undef RS
#undef OFFSET
#undef TRS
#undef ERS
#line 4078 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGEZL_REGIMM (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGEZL_REGIMM
#undef BGEZL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BGEZL_REGIMM
#undef MY_NAME
#define MY_NAME "BGEZL_REGIMM"

  /* Extraction: BGEZL
       #define do-not-use-icache
       6.0x1,5.RS,5.0x3,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 4107 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x3,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2032 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgezl r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 4125 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGEZL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2045 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] >= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 4159 "semantics.c"
  return nia;
  /* Extraction: BGEZL
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x3,16.OFFSET */

#undef RS
#undef OFFSET
#undef TRS
#undef ERS
#line 4169 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TGEI_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TGEI_REGIMM
#undef TGEI_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TGEI_REGIMM
#undef MY_NAME
#define MY_NAME "TGEI_REGIMM"

  /* Extraction: TGEI
       #define do-not-use-icache
       6.0x1,5.RS,5.0x8,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#undef IMM_DEC1
#define IMM_DEC1 ((int) ((IMMEDIATE == 7) ? -1 : ((IMMEDIATE == 0) ? 1 : IMMEDIATE << 2))) /* scratch - extraction */
#undef IMM_DEC2
#define IMM_DEC2 ((int) ((IMMEDIATE < 8) ? IMMEDIATE : (IMMEDIATE - 16))) /* scratch - extraction */
#undef IMM_DEC3
#define IMM_DEC3 ((int) ((IMMEDIATE < 2) ? IMMEDIATE + 256 : ((IMMEDIATE < 256) ? IMMEDIATE : ((IMMEDIATE < 510) ? IMMEDIATE - 512 : IMMEDIATE - 768)))) /* scratch - extraction */
#undef IMM_DEC4
#define IMM_DEC4 ((int) (compute_andi16_imm (SD_, IMMEDIATE))) /* scratch - extraction */
#undef IMM_DEC5
#define IMM_DEC5 ((int) ((IMMEDIATE < 15) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_DEC6
#define IMM_DEC6 ((int) ((IMMEDIATE < 127) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_SHIFT_1BIT
#define IMM_SHIFT_1BIT ((int) (IMMEDIATE << 1)) /* scratch - extraction */
#undef IMM_SHIFT_2BIT
#define IMM_SHIFT_2BIT ((int) (IMMEDIATE << 2)) /* scratch - extraction */
#line 4214 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x8,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4720 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tgei r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 4232 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TGEI_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4732 "./mips.igen"
    do_tgei (SD_, RS, IMMEDIATE, instruction_0);
  }
#line 4260 "semantics.c"
  return nia;
  /* Extraction: TGEI
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x8,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#undef TRS
#undef ERS
#undef IMM_DEC1
#undef IMM_DEC2
#undef IMM_DEC3
#undef IMM_DEC4
#undef IMM_DEC5
#undef IMM_DEC6
#undef IMM_SHIFT_1BIT
#undef IMM_SHIFT_2BIT
#line 4278 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TGEIU_REGIMM (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TGEIU_REGIMM
#undef TGEIU_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TGEIU_REGIMM
#undef MY_NAME
#define MY_NAME "TGEIU_REGIMM"

  /* Extraction: TGEIU
       #define do-not-use-icache
       6.0x1,5.RS,5.0x9,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#undef IMM_DEC1
#define IMM_DEC1 ((int) ((IMMEDIATE == 7) ? -1 : ((IMMEDIATE == 0) ? 1 : IMMEDIATE << 2))) /* scratch - extraction */
#undef IMM_DEC2
#define IMM_DEC2 ((int) ((IMMEDIATE < 8) ? IMMEDIATE : (IMMEDIATE - 16))) /* scratch - extraction */
#undef IMM_DEC3
#define IMM_DEC3 ((int) ((IMMEDIATE < 2) ? IMMEDIATE + 256 : ((IMMEDIATE < 256) ? IMMEDIATE : ((IMMEDIATE < 510) ? IMMEDIATE - 512 : IMMEDIATE - 768)))) /* scratch - extraction */
#undef IMM_DEC4
#define IMM_DEC4 ((int) (compute_andi16_imm (SD_, IMMEDIATE))) /* scratch - extraction */
#undef IMM_DEC5
#define IMM_DEC5 ((int) ((IMMEDIATE < 15) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_DEC6
#define IMM_DEC6 ((int) ((IMMEDIATE < 127) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_SHIFT_1BIT
#define IMM_SHIFT_1BIT ((int) (IMMEDIATE << 1)) /* scratch - extraction */
#undef IMM_SHIFT_2BIT
#define IMM_SHIFT_2BIT ((int) (IMMEDIATE << 2)) /* scratch - extraction */
#line 4323 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x9,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4737 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tgeiu r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 4341 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TGEIU_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4749 "./mips.igen"
    do_tgeiu (SD_, RS, IMMEDIATE, instruction_0);
  }
#line 4369 "semantics.c"
  return nia;
  /* Extraction: TGEIU
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x9,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#undef TRS
#undef ERS
#undef IMM_DEC1
#undef IMM_DEC2
#undef IMM_DEC3
#undef IMM_DEC4
#undef IMM_DEC5
#undef IMM_DEC6
#undef IMM_SHIFT_1BIT
#undef IMM_SHIFT_2BIT
#line 4387 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLTI_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLTI_REGIMM
#undef TLTI_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TLTI_REGIMM
#undef MY_NAME
#define MY_NAME "TLTI_REGIMM"

  /* Extraction: TLTI
       #define do-not-use-icache
       6.0x1,5.RS,5.0xa,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#undef IMM_DEC1
#define IMM_DEC1 ((int) ((IMMEDIATE == 7) ? -1 : ((IMMEDIATE == 0) ? 1 : IMMEDIATE << 2))) /* scratch - extraction */
#undef IMM_DEC2
#define IMM_DEC2 ((int) ((IMMEDIATE < 8) ? IMMEDIATE : (IMMEDIATE - 16))) /* scratch - extraction */
#undef IMM_DEC3
#define IMM_DEC3 ((int) ((IMMEDIATE < 2) ? IMMEDIATE + 256 : ((IMMEDIATE < 256) ? IMMEDIATE : ((IMMEDIATE < 510) ? IMMEDIATE - 512 : IMMEDIATE - 768)))) /* scratch - extraction */
#undef IMM_DEC4
#define IMM_DEC4 ((int) (compute_andi16_imm (SD_, IMMEDIATE))) /* scratch - extraction */
#undef IMM_DEC5
#define IMM_DEC5 ((int) ((IMMEDIATE < 15) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_DEC6
#define IMM_DEC6 ((int) ((IMMEDIATE < 127) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_SHIFT_1BIT
#define IMM_SHIFT_1BIT ((int) (IMMEDIATE << 1)) /* scratch - extraction */
#undef IMM_SHIFT_2BIT
#define IMM_SHIFT_2BIT ((int) (IMMEDIATE << 2)) /* scratch - extraction */
#line 4432 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0xa,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4788 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlti r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 4450 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLTI_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4800 "./mips.igen"
    do_tlti (SD_, RS, IMMEDIATE, instruction_0);
  }
#line 4478 "semantics.c"
  return nia;
  /* Extraction: TLTI
       #undef do-not-use-icache
       6.0x1,5.RS,5.0xa,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#undef TRS
#undef ERS
#undef IMM_DEC1
#undef IMM_DEC2
#undef IMM_DEC3
#undef IMM_DEC4
#undef IMM_DEC5
#undef IMM_DEC6
#undef IMM_SHIFT_1BIT
#undef IMM_SHIFT_2BIT
#line 4496 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLTIU_REGIMM (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLTIU_REGIMM
#undef TLTIU_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TLTIU_REGIMM
#undef MY_NAME
#define MY_NAME "TLTIU_REGIMM"

  /* Extraction: TLTIU
       #define do-not-use-icache
       6.0x1,5.RS,5.0xb,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#undef IMM_DEC1
#define IMM_DEC1 ((int) ((IMMEDIATE == 7) ? -1 : ((IMMEDIATE == 0) ? 1 : IMMEDIATE << 2))) /* scratch - extraction */
#undef IMM_DEC2
#define IMM_DEC2 ((int) ((IMMEDIATE < 8) ? IMMEDIATE : (IMMEDIATE - 16))) /* scratch - extraction */
#undef IMM_DEC3
#define IMM_DEC3 ((int) ((IMMEDIATE < 2) ? IMMEDIATE + 256 : ((IMMEDIATE < 256) ? IMMEDIATE : ((IMMEDIATE < 510) ? IMMEDIATE - 512 : IMMEDIATE - 768)))) /* scratch - extraction */
#undef IMM_DEC4
#define IMM_DEC4 ((int) (compute_andi16_imm (SD_, IMMEDIATE))) /* scratch - extraction */
#undef IMM_DEC5
#define IMM_DEC5 ((int) ((IMMEDIATE < 15) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_DEC6
#define IMM_DEC6 ((int) ((IMMEDIATE < 127) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_SHIFT_1BIT
#define IMM_SHIFT_1BIT ((int) (IMMEDIATE << 1)) /* scratch - extraction */
#undef IMM_SHIFT_2BIT
#define IMM_SHIFT_2BIT ((int) (IMMEDIATE << 2)) /* scratch - extraction */
#line 4541 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0xb,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4805 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tltiu r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 4559 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLTIU_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4817 "./mips.igen"
    do_tltiu (SD_, RS, IMMEDIATE, instruction_0);
  }
#line 4587 "semantics.c"
  return nia;
  /* Extraction: TLTIU
       #undef do-not-use-icache
       6.0x1,5.RS,5.0xb,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#undef TRS
#undef ERS
#undef IMM_DEC1
#undef IMM_DEC2
#undef IMM_DEC3
#undef IMM_DEC4
#undef IMM_DEC5
#undef IMM_DEC6
#undef IMM_SHIFT_1BIT
#undef IMM_SHIFT_2BIT
#line 4605 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TEQI_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TEQI_REGIMM
#undef TEQI_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TEQI_REGIMM
#undef MY_NAME
#define MY_NAME "TEQI_REGIMM"

  /* Extraction: TEQI
       #define do-not-use-icache
       6.0x1,5.RS,5.0xc,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#undef IMM_DEC1
#define IMM_DEC1 ((int) ((IMMEDIATE == 7) ? -1 : ((IMMEDIATE == 0) ? 1 : IMMEDIATE << 2))) /* scratch - extraction */
#undef IMM_DEC2
#define IMM_DEC2 ((int) ((IMMEDIATE < 8) ? IMMEDIATE : (IMMEDIATE - 16))) /* scratch - extraction */
#undef IMM_DEC3
#define IMM_DEC3 ((int) ((IMMEDIATE < 2) ? IMMEDIATE + 256 : ((IMMEDIATE < 256) ? IMMEDIATE : ((IMMEDIATE < 510) ? IMMEDIATE - 512 : IMMEDIATE - 768)))) /* scratch - extraction */
#undef IMM_DEC4
#define IMM_DEC4 ((int) (compute_andi16_imm (SD_, IMMEDIATE))) /* scratch - extraction */
#undef IMM_DEC5
#define IMM_DEC5 ((int) ((IMMEDIATE < 15) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_DEC6
#define IMM_DEC6 ((int) ((IMMEDIATE < 127) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_SHIFT_1BIT
#define IMM_SHIFT_1BIT ((int) (IMMEDIATE << 1)) /* scratch - extraction */
#undef IMM_SHIFT_2BIT
#define IMM_SHIFT_2BIT ((int) (IMMEDIATE << 2)) /* scratch - extraction */
#line 4650 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0xc,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4686 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "teqi r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 4668 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TEQI_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4698 "./mips.igen"
    do_teqi (SD_, RS, IMMEDIATE, instruction_0);
  }
#line 4696 "semantics.c"
  return nia;
  /* Extraction: TEQI
       #undef do-not-use-icache
       6.0x1,5.RS,5.0xc,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#undef TRS
#undef ERS
#undef IMM_DEC1
#undef IMM_DEC2
#undef IMM_DEC3
#undef IMM_DEC4
#undef IMM_DEC5
#undef IMM_DEC6
#undef IMM_SHIFT_1BIT
#undef IMM_SHIFT_2BIT
#line 4714 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TNEI_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TNEI_REGIMM
#undef TNEI_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TNEI_REGIMM
#undef MY_NAME
#define MY_NAME "TNEI_REGIMM"

  /* Extraction: TNEI
       #define do-not-use-icache
       6.0x1,5.RS,5.0xe,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#undef IMM_DEC1
#define IMM_DEC1 ((int) ((IMMEDIATE == 7) ? -1 : ((IMMEDIATE == 0) ? 1 : IMMEDIATE << 2))) /* scratch - extraction */
#undef IMM_DEC2
#define IMM_DEC2 ((int) ((IMMEDIATE < 8) ? IMMEDIATE : (IMMEDIATE - 16))) /* scratch - extraction */
#undef IMM_DEC3
#define IMM_DEC3 ((int) ((IMMEDIATE < 2) ? IMMEDIATE + 256 : ((IMMEDIATE < 256) ? IMMEDIATE : ((IMMEDIATE < 510) ? IMMEDIATE - 512 : IMMEDIATE - 768)))) /* scratch - extraction */
#undef IMM_DEC4
#define IMM_DEC4 ((int) (compute_andi16_imm (SD_, IMMEDIATE))) /* scratch - extraction */
#undef IMM_DEC5
#define IMM_DEC5 ((int) ((IMMEDIATE < 15) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_DEC6
#define IMM_DEC6 ((int) ((IMMEDIATE < 127) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_SHIFT_1BIT
#define IMM_SHIFT_1BIT ((int) (IMMEDIATE << 1)) /* scratch - extraction */
#undef IMM_SHIFT_2BIT
#define IMM_SHIFT_2BIT ((int) (IMMEDIATE << 2)) /* scratch - extraction */
#line 4759 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0xe,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4856 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tnei r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 4777 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TNEI_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4868 "./mips.igen"
    do_tnei (SD_, RS, IMMEDIATE, instruction_0);
  }
#line 4805 "semantics.c"
  return nia;
  /* Extraction: TNEI
       #undef do-not-use-icache
       6.0x1,5.RS,5.0xe,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#undef TRS
#undef ERS
#undef IMM_DEC1
#undef IMM_DEC2
#undef IMM_DEC3
#undef IMM_DEC4
#undef IMM_DEC5
#undef IMM_DEC6
#undef IMM_SHIFT_1BIT
#undef IMM_SHIFT_2BIT
#line 4823 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLTZAL_REGIMM (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLTZAL_REGIMM
#undef BLTZAL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BLTZAL_REGIMM
#undef MY_NAME
#define MY_NAME "BLTZAL_REGIMM"

  /* Extraction: BLTZAL
       #define do-not-use-icache
       6.0x1,5.RS!31,5.0x10,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 4852 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS!31,5.0x10,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2183 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bltzal r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 4870 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLTZAL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2197 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if (RS == 31)
      Unpredictable ();
    RA = (CIA + 8);
    /* NOTE: The branch occurs AFTER the next instruction has been
       executed */
    if ((signed_word) GPR[RS] < 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 4907 "semantics.c"
  return nia;
  /* Extraction: BLTZAL
       #undef do-not-use-icache
       6.0x1,5.RS!31,5.0x10,16.OFFSET */

#undef RS
#undef OFFSET
#undef TRS
#undef ERS
#line 4917 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGEZAL_REGIMM (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGEZAL_REGIMM
#undef BGEZAL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BGEZAL_REGIMM
#undef MY_NAME
#define MY_NAME "BGEZAL_REGIMM"

  /* Extraction: BGEZAL
       #define do-not-use-icache
       6.0x1,5.RS!31,5.0x11,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 4946 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS!31,5.0x11,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1975 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgezal r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 4964 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGEZAL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1989 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if (RS == 31)
      Unpredictable ();
    RA = (CIA + 8);
    if ((signed_word) GPR[RS] >= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 4999 "semantics.c"
  return nia;
  /* Extraction: BGEZAL
       #undef do-not-use-icache
       6.0x1,5.RS!31,5.0x11,16.OFFSET */

#undef RS
#undef OFFSET
#undef TRS
#undef ERS
#line 5009 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLTZALL_REGIMM (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLTZALL_REGIMM
#undef BLTZALL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BLTZALL_REGIMM
#undef MY_NAME
#define MY_NAME "BLTZALL_REGIMM"

  /* Extraction: BLTZALL
       #define do-not-use-icache
       6.0x1,5.RS!31,5.0x12,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 5038 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS!31,5.0x12,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2212 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bltzall r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 5056 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLTZALL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2225 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if (RS == 31)
      Unpredictable ();
    RA = (CIA + 8);
    if ((signed_word) GPR[RS] < 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 5093 "semantics.c"
  return nia;
  /* Extraction: BLTZALL
       #undef do-not-use-icache
       6.0x1,5.RS!31,5.0x12,16.OFFSET */

#undef RS
#undef OFFSET
#undef TRS
#undef ERS
#line 5103 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGEZALL_REGIMM (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGEZALL_REGIMM
#undef BGEZALL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BGEZALL_REGIMM
#undef MY_NAME
#define MY_NAME "BGEZALL_REGIMM"

  /* Extraction: BGEZALL
       #define do-not-use-icache
       6.0x1,5.RS!31,5.0x13,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 5132 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS!31,5.0x13,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2002 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgezall r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 5150 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGEZALL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2015 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if (RS == 31)
      Unpredictable ();
    RA = (CIA + 8);
    /* NOTE: The branch occurs AFTER the next instruction has been
       executed */
    if ((signed_word) GPR[RS] >= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 5189 "semantics.c"
  return nia;
  /* Extraction: BGEZALL
       #undef do-not-use-icache
       6.0x1,5.RS!31,5.0x13,16.OFFSET */

#undef RS
#undef OFFSET
#undef TRS
#undef ERS
#line 5199 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_J_NORMAL (SIM_DESC sd,
                   instruction_word instruction_0,
                   instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_J_NORMAL
#undef J_NORMAL
#undef MY_PREFIX
#define MY_PREFIX J_NORMAL
#undef MY_NAME
#define MY_NAME "J_NORMAL"

  /* Extraction: J
       #define do-not-use-icache
       6.0x2,26.INSTR_INDEX */

#undef INSTR_INDEX
#define INSTR_INDEX ((unsigned) MASKED32 (instruction_0, 25, 0)) /* cache - extraction */
#line 5222 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2,26.INSTR_INDEX */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3020 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "j %ld", \
                    (long) INSTR_INDEX);
#line 5239 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_J_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3034 "./mips.igen"
    /* NOTE: The region used is that of the delay slot NIA and NOT the
       current instruction */
    address_word region = (NIA & MASK (63, 28));
    DELAY_SLOT (region | (INSTR_INDEX << 2));
  }
#line 5270 "semantics.c"
  return nia;
  /* Extraction: J
       #undef do-not-use-icache
       6.0x2,26.INSTR_INDEX */

#undef INSTR_INDEX
#line 5277 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_JAL_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_JAL_NORMAL
#undef JAL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX JAL_NORMAL
#undef MY_NAME
#define MY_NAME "JAL_NORMAL"

  /* Extraction: JAL
       #define do-not-use-icache
       6.0x3,26.INSTR_INDEX */

#undef INSTR_INDEX
#define INSTR_INDEX ((unsigned) MASKED32 (instruction_0, 25, 0)) /* cache - extraction */
#line 5300 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x3,26.INSTR_INDEX */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3042 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "jal %ld", \
                    (long) INSTR_INDEX);
#line 5317 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_JAL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3056 "./mips.igen"
    /* NOTE: The region used is that of the delay slot and NOT the
       current instruction */
    address_word region = (NIA & MASK (63, 28));
    GPR[31] = CIA + 8;
    DELAY_SLOT (region | (INSTR_INDEX << 2));
  }
#line 5349 "semantics.c"
  return nia;
  /* Extraction: JAL
       #undef do-not-use-icache
       6.0x3,26.INSTR_INDEX */

#undef INSTR_INDEX
#line 5356 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BEQ_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BEQ_NORMAL
#undef BEQ_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BEQ_NORMAL
#undef MY_NAME
#define MY_NAME "BEQ_NORMAL"

  /* Extraction: BEQ
       #define do-not-use-icache
       6.0x4,5.RS,5.RT,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 5391 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x4,5.RS,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1902 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "beq r%ld, r%ld, %ld", \
                    (long) RS, \
                    (long) RT, \
                    (long) OFFSET);
#line 5410 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BEQ_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1916 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] == (signed_word) GPR[RT])
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 5442 "semantics.c"
  return nia;
  /* Extraction: BEQ
       #undef do-not-use-icache
       6.0x4,5.RS,5.RT,16.OFFSET */

#undef RS
#undef RT
#undef OFFSET
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 5455 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BNE_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BNE_NORMAL
#undef BNE_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BNE_NORMAL
#undef MY_NAME
#define MY_NAME "BNE_NORMAL"

  /* Extraction: BNE
       #define do-not-use-icache
       6.0x5,5.RS,5.RT,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 5490 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x5,5.RS,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2267 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bne r%ld, r%ld, %ld", \
                    (long) RS, \
                    (long) RT, \
                    (long) OFFSET);
#line 5509 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BNE_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2281 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] != (signed_word) GPR[RT])
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 5541 "semantics.c"
  return nia;
  /* Extraction: BNE
       #undef do-not-use-icache
       6.0x5,5.RS,5.RT,16.OFFSET */

#undef RS
#undef RT
#undef OFFSET
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 5554 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLEZ_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLEZ_NORMAL
#undef BLEZ_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BLEZ_NORMAL
#undef MY_NAME
#define MY_NAME "BLEZ_NORMAL"

  /* Extraction: BLEZ
       #define do-not-use-icache
       6.0x6,5.RS,5.0x0,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 5583 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x6,5.RS,5.0x0,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2108 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "blez r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 5606 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLEZ_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2122 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    /* NOTE: The branch occurs AFTER the next instruction has been
       executed */
    if ((signed_word) GPR[RS] <= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 5640 "semantics.c"
  return nia;
  /* Extraction: BLEZ
       #undef do-not-use-icache
       6.0x6,5.RS,5.0x0,16.OFFSET */

#undef RS
#undef OFFSET
#undef TRS
#undef ERS
#line 5650 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGTZ_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGTZ_NORMAL
#undef BGTZ_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BGTZ_NORMAL
#undef MY_NAME
#define MY_NAME "BGTZ_NORMAL"

  /* Extraction: BGTZ
       #define do-not-use-icache
       6.0x7,5.RS,5.0x0,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 5679 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x7,5.RS,5.0x0,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2057 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgtz r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 5702 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGTZ_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2071 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] > 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 5734 "semantics.c"
  return nia;
  /* Extraction: BGTZ
       #undef do-not-use-icache
       6.0x7,5.RS,5.0x0,16.OFFSET */

#undef RS
#undef OFFSET
#undef TRS
#undef ERS
#line 5744 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ADDI_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ADDI_NORMAL
#undef ADDI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX ADDI_NORMAL
#undef MY_NAME
#define MY_NAME "ADDI_NORMAL"

  /* Extraction: ADDI
       #define do-not-use-icache
       6.0x8,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#undef IMM_DEC1
#define IMM_DEC1 ((int) ((IMMEDIATE == 7) ? -1 : ((IMMEDIATE == 0) ? 1 : IMMEDIATE << 2))) /* scratch - extraction */
#undef IMM_DEC2
#define IMM_DEC2 ((int) ((IMMEDIATE < 8) ? IMMEDIATE : (IMMEDIATE - 16))) /* scratch - extraction */
#undef IMM_DEC3
#define IMM_DEC3 ((int) ((IMMEDIATE < 2) ? IMMEDIATE + 256 : ((IMMEDIATE < 256) ? IMMEDIATE : ((IMMEDIATE < 510) ? IMMEDIATE - 512 : IMMEDIATE - 768)))) /* scratch - extraction */
#undef IMM_DEC4
#define IMM_DEC4 ((int) (compute_andi16_imm (SD_, IMMEDIATE))) /* scratch - extraction */
#undef IMM_DEC5
#define IMM_DEC5 ((int) ((IMMEDIATE < 15) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_DEC6
#define IMM_DEC6 ((int) ((IMMEDIATE < 127) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_SHIFT_1BIT
#define IMM_SHIFT_1BIT ((int) (IMMEDIATE << 1)) /* scratch - extraction */
#undef IMM_SHIFT_2BIT
#define IMM_SHIFT_2BIT ((int) (IMMEDIATE << 2)) /* scratch - extraction */
#line 5795 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x8,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1777 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "addi r%ld, r%ld, %ld", \
                    (long) RT, \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 5814 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ADDI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1791 "./mips.igen"
    do_addi (SD_, RS, RT, IMMEDIATE);
  }
#line 5842 "semantics.c"
  return nia;
  /* Extraction: ADDI
       #undef do-not-use-icache
       6.0x8,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#undef IMM_DEC1
#undef IMM_DEC2
#undef IMM_DEC3
#undef IMM_DEC4
#undef IMM_DEC5
#undef IMM_DEC6
#undef IMM_SHIFT_1BIT
#undef IMM_SHIFT_2BIT
#line 5863 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ADDIU_NORMAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ADDIU_NORMAL
#undef ADDIU_NORMAL
#undef MY_PREFIX
#define MY_PREFIX ADDIU_NORMAL
#undef MY_NAME
#define MY_NAME "ADDIU_NORMAL"

  /* Extraction: ADDIU
       #define do-not-use-icache
       6.0x9,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#undef IMM_DEC1
#define IMM_DEC1 ((int) ((IMMEDIATE == 7) ? -1 : ((IMMEDIATE == 0) ? 1 : IMMEDIATE << 2))) /* scratch - extraction */
#undef IMM_DEC2
#define IMM_DEC2 ((int) ((IMMEDIATE < 8) ? IMMEDIATE : (IMMEDIATE - 16))) /* scratch - extraction */
#undef IMM_DEC3
#define IMM_DEC3 ((int) ((IMMEDIATE < 2) ? IMMEDIATE + 256 : ((IMMEDIATE < 256) ? IMMEDIATE : ((IMMEDIATE < 510) ? IMMEDIATE - 512 : IMMEDIATE - 768)))) /* scratch - extraction */
#undef IMM_DEC4
#define IMM_DEC4 ((int) (compute_andi16_imm (SD_, IMMEDIATE))) /* scratch - extraction */
#undef IMM_DEC5
#define IMM_DEC5 ((int) ((IMMEDIATE < 15) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_DEC6
#define IMM_DEC6 ((int) ((IMMEDIATE < 127) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_SHIFT_1BIT
#define IMM_SHIFT_1BIT ((int) (IMMEDIATE << 1)) /* scratch - extraction */
#undef IMM_SHIFT_2BIT
#define IMM_SHIFT_2BIT ((int) (IMMEDIATE << 2)) /* scratch - extraction */
#line 5914 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x9,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1806 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "addiu r%ld, r%ld, %ld", \
                    (long) RT, \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 5933 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ADDIU_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1820 "./mips.igen"
    do_addiu (SD_, RS, RT, IMMEDIATE);
  }
#line 5961 "semantics.c"
  return nia;
  /* Extraction: ADDIU
       #undef do-not-use-icache
       6.0x9,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#undef IMM_DEC1
#undef IMM_DEC2
#undef IMM_DEC3
#undef IMM_DEC4
#undef IMM_DEC5
#undef IMM_DEC6
#undef IMM_SHIFT_1BIT
#undef IMM_SHIFT_2BIT
#line 5982 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLTI_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLTI_NORMAL
#undef SLTI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SLTI_NORMAL
#undef MY_NAME
#define MY_NAME "SLTI_NORMAL"

  /* Extraction: SLTI
       #define do-not-use-icache
       6.0xa,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#undef IMM_DEC1
#define IMM_DEC1 ((int) ((IMMEDIATE == 7) ? -1 : ((IMMEDIATE == 0) ? 1 : IMMEDIATE << 2))) /* scratch - extraction */
#undef IMM_DEC2
#define IMM_DEC2 ((int) ((IMMEDIATE < 8) ? IMMEDIATE : (IMMEDIATE - 16))) /* scratch - extraction */
#undef IMM_DEC3
#define IMM_DEC3 ((int) ((IMMEDIATE < 2) ? IMMEDIATE + 256 : ((IMMEDIATE < 256) ? IMMEDIATE : ((IMMEDIATE < 510) ? IMMEDIATE - 512 : IMMEDIATE - 768)))) /* scratch - extraction */
#undef IMM_DEC4
#define IMM_DEC4 ((int) (compute_andi16_imm (SD_, IMMEDIATE))) /* scratch - extraction */
#undef IMM_DEC5
#define IMM_DEC5 ((int) ((IMMEDIATE < 15) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_DEC6
#define IMM_DEC6 ((int) ((IMMEDIATE < 127) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_SHIFT_1BIT
#define IMM_SHIFT_1BIT ((int) (IMMEDIATE << 1)) /* scratch - extraction */
#undef IMM_SHIFT_2BIT
#define IMM_SHIFT_2BIT ((int) (IMMEDIATE << 2)) /* scratch - extraction */
#line 6033 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xa,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4316 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "slti r%ld, r%ld, %ld", \
                    (long) RT, \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 6052 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLTI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4330 "./mips.igen"
    do_slti (SD_, RS, RT, IMMEDIATE);
  }
#line 6080 "semantics.c"
  return nia;
  /* Extraction: SLTI
       #undef do-not-use-icache
       6.0xa,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#undef IMM_DEC1
#undef IMM_DEC2
#undef IMM_DEC3
#undef IMM_DEC4
#undef IMM_DEC5
#undef IMM_DEC6
#undef IMM_SHIFT_1BIT
#undef IMM_SHIFT_2BIT
#line 6101 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLTIU_NORMAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLTIU_NORMAL
#undef SLTIU_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SLTIU_NORMAL
#undef MY_NAME
#define MY_NAME "SLTIU_NORMAL"

  /* Extraction: SLTIU
       #define do-not-use-icache
       6.0xb,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#undef IMM_DEC1
#define IMM_DEC1 ((int) ((IMMEDIATE == 7) ? -1 : ((IMMEDIATE == 0) ? 1 : IMMEDIATE << 2))) /* scratch - extraction */
#undef IMM_DEC2
#define IMM_DEC2 ((int) ((IMMEDIATE < 8) ? IMMEDIATE : (IMMEDIATE - 16))) /* scratch - extraction */
#undef IMM_DEC3
#define IMM_DEC3 ((int) ((IMMEDIATE < 2) ? IMMEDIATE + 256 : ((IMMEDIATE < 256) ? IMMEDIATE : ((IMMEDIATE < 510) ? IMMEDIATE - 512 : IMMEDIATE - 768)))) /* scratch - extraction */
#undef IMM_DEC4
#define IMM_DEC4 ((int) (compute_andi16_imm (SD_, IMMEDIATE))) /* scratch - extraction */
#undef IMM_DEC5
#define IMM_DEC5 ((int) ((IMMEDIATE < 15) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_DEC6
#define IMM_DEC6 ((int) ((IMMEDIATE < 127) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_SHIFT_1BIT
#define IMM_SHIFT_1BIT ((int) (IMMEDIATE << 1)) /* scratch - extraction */
#undef IMM_SHIFT_2BIT
#define IMM_SHIFT_2BIT ((int) (IMMEDIATE << 2)) /* scratch - extraction */
#line 6152 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xb,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4342 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sltiu r%ld, r%ld, %ld", \
                    (long) RT, \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 6171 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLTIU_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4356 "./mips.igen"
    do_sltiu (SD_, RS, RT, IMMEDIATE);
  }
#line 6199 "semantics.c"
  return nia;
  /* Extraction: SLTIU
       #undef do-not-use-icache
       6.0xb,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#undef IMM_DEC1
#undef IMM_DEC2
#undef IMM_DEC3
#undef IMM_DEC4
#undef IMM_DEC5
#undef IMM_DEC6
#undef IMM_SHIFT_1BIT
#undef IMM_SHIFT_2BIT
#line 6220 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ANDI_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ANDI_NORMAL
#undef ANDI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX ANDI_NORMAL
#undef MY_NAME
#define MY_NAME "ANDI_NORMAL"

  /* Extraction: ANDI
       #define do-not-use-icache
       6.0xc,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#undef IMM_DEC1
#define IMM_DEC1 ((int) ((IMMEDIATE == 7) ? -1 : ((IMMEDIATE == 0) ? 1 : IMMEDIATE << 2))) /* scratch - extraction */
#undef IMM_DEC2
#define IMM_DEC2 ((int) ((IMMEDIATE < 8) ? IMMEDIATE : (IMMEDIATE - 16))) /* scratch - extraction */
#undef IMM_DEC3
#define IMM_DEC3 ((int) ((IMMEDIATE < 2) ? IMMEDIATE + 256 : ((IMMEDIATE < 256) ? IMMEDIATE : ((IMMEDIATE < 510) ? IMMEDIATE - 512 : IMMEDIATE - 768)))) /* scratch - extraction */
#undef IMM_DEC4
#define IMM_DEC4 ((int) (compute_andi16_imm (SD_, IMMEDIATE))) /* scratch - extraction */
#undef IMM_DEC5
#define IMM_DEC5 ((int) ((IMMEDIATE < 15) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_DEC6
#define IMM_DEC6 ((int) ((IMMEDIATE < 127) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_SHIFT_1BIT
#define IMM_SHIFT_1BIT ((int) (IMMEDIATE << 1)) /* scratch - extraction */
#undef IMM_SHIFT_2BIT
#define IMM_SHIFT_2BIT ((int) (IMMEDIATE << 2)) /* scratch - extraction */
#line 6271 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xc,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1882 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "andi r%ld, r%ld, %#lx", \
                    (long) RT, \
                    (long) RS, \
                    (unsigned long) IMMEDIATE);
#line 6290 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ANDI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1896 "./mips.igen"
    do_andi (SD_,RS, RT, IMMEDIATE);
  }
#line 6318 "semantics.c"
  return nia;
  /* Extraction: ANDI
       #undef do-not-use-icache
       6.0xc,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#undef IMM_DEC1
#undef IMM_DEC2
#undef IMM_DEC3
#undef IMM_DEC4
#undef IMM_DEC5
#undef IMM_DEC6
#undef IMM_SHIFT_1BIT
#undef IMM_SHIFT_2BIT
#line 6339 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ORI_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ORI_NORMAL
#undef ORI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX ORI_NORMAL
#undef MY_NAME
#define MY_NAME "ORI_NORMAL"

  /* Extraction: ORI
       #define do-not-use-icache
       6.0xd,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#undef IMM_DEC1
#define IMM_DEC1 ((int) ((IMMEDIATE == 7) ? -1 : ((IMMEDIATE == 0) ? 1 : IMMEDIATE << 2))) /* scratch - extraction */
#undef IMM_DEC2
#define IMM_DEC2 ((int) ((IMMEDIATE < 8) ? IMMEDIATE : (IMMEDIATE - 16))) /* scratch - extraction */
#undef IMM_DEC3
#define IMM_DEC3 ((int) ((IMMEDIATE < 2) ? IMMEDIATE + 256 : ((IMMEDIATE < 256) ? IMMEDIATE : ((IMMEDIATE < 510) ? IMMEDIATE - 512 : IMMEDIATE - 768)))) /* scratch - extraction */
#undef IMM_DEC4
#define IMM_DEC4 ((int) (compute_andi16_imm (SD_, IMMEDIATE))) /* scratch - extraction */
#undef IMM_DEC5
#define IMM_DEC5 ((int) ((IMMEDIATE < 15) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_DEC6
#define IMM_DEC6 ((int) ((IMMEDIATE < 127) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_SHIFT_1BIT
#define IMM_SHIFT_1BIT ((int) (IMMEDIATE << 1)) /* scratch - extraction */
#undef IMM_SHIFT_2BIT
#define IMM_SHIFT_2BIT ((int) (IMMEDIATE << 2)) /* scratch - extraction */
#line 6390 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xd,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3929 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ori r%ld, r%ld, %#lx", \
                    (long) RT, \
                    (long) RS, \
                    (unsigned long) IMMEDIATE);
#line 6409 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ORI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3943 "./mips.igen"
    do_ori (SD_, RS, RT, IMMEDIATE);
  }
#line 6437 "semantics.c"
  return nia;
  /* Extraction: ORI
       #undef do-not-use-icache
       6.0xd,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#undef IMM_DEC1
#undef IMM_DEC2
#undef IMM_DEC3
#undef IMM_DEC4
#undef IMM_DEC5
#undef IMM_DEC6
#undef IMM_SHIFT_1BIT
#undef IMM_SHIFT_2BIT
#line 6458 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_XORI_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_XORI_NORMAL
#undef XORI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX XORI_NORMAL
#undef MY_NAME
#define MY_NAME "XORI_NORMAL"

  /* Extraction: XORI
       #define do-not-use-icache
       6.0xe,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#undef IMM_DEC1
#define IMM_DEC1 ((int) ((IMMEDIATE == 7) ? -1 : ((IMMEDIATE == 0) ? 1 : IMMEDIATE << 2))) /* scratch - extraction */
#undef IMM_DEC2
#define IMM_DEC2 ((int) ((IMMEDIATE < 8) ? IMMEDIATE : (IMMEDIATE - 16))) /* scratch - extraction */
#undef IMM_DEC3
#define IMM_DEC3 ((int) ((IMMEDIATE < 2) ? IMMEDIATE + 256 : ((IMMEDIATE < 256) ? IMMEDIATE : ((IMMEDIATE < 510) ? IMMEDIATE - 512 : IMMEDIATE - 768)))) /* scratch - extraction */
#undef IMM_DEC4
#define IMM_DEC4 ((int) (compute_andi16_imm (SD_, IMMEDIATE))) /* scratch - extraction */
#undef IMM_DEC5
#define IMM_DEC5 ((int) ((IMMEDIATE < 15) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_DEC6
#define IMM_DEC6 ((int) ((IMMEDIATE < 127) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_SHIFT_1BIT
#define IMM_SHIFT_1BIT ((int) (IMMEDIATE << 1)) /* scratch - extraction */
#undef IMM_SHIFT_2BIT
#define IMM_SHIFT_2BIT ((int) (IMMEDIATE << 2)) /* scratch - extraction */
#line 6509 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xe,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4906 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "xori r%ld, r%ld, %#lx", \
                    (long) RT, \
                    (long) RS, \
                    (unsigned long) IMMEDIATE);
#line 6528 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_XORI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4920 "./mips.igen"
    do_xori (SD_, RS, RT, IMMEDIATE);
  }
#line 6556 "semantics.c"
  return nia;
  /* Extraction: XORI
       #undef do-not-use-icache
       6.0xe,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#undef IMM_DEC1
#undef IMM_DEC2
#undef IMM_DEC3
#undef IMM_DEC4
#undef IMM_DEC5
#undef IMM_DEC6
#undef IMM_SHIFT_1BIT
#undef IMM_SHIFT_2BIT
#line 6577 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LUI_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LUI_NORMAL
#undef LUI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LUI_NORMAL
#undef MY_NAME
#define MY_NAME "LUI_NORMAL"

  /* Extraction: LUI
       #define do-not-use-icache
       6.0xf,5.0x0,5.RT,16.IMMEDIATE */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef IMM_DEC1
#define IMM_DEC1 ((int) ((IMMEDIATE == 7) ? -1 : ((IMMEDIATE == 0) ? 1 : IMMEDIATE << 2))) /* scratch - extraction */
#undef IMM_DEC2
#define IMM_DEC2 ((int) ((IMMEDIATE < 8) ? IMMEDIATE : (IMMEDIATE - 16))) /* scratch - extraction */
#undef IMM_DEC3
#define IMM_DEC3 ((int) ((IMMEDIATE < 2) ? IMMEDIATE + 256 : ((IMMEDIATE < 256) ? IMMEDIATE : ((IMMEDIATE < 510) ? IMMEDIATE - 512 : IMMEDIATE - 768)))) /* scratch - extraction */
#undef IMM_DEC4
#define IMM_DEC4 ((int) (compute_andi16_imm (SD_, IMMEDIATE))) /* scratch - extraction */
#undef IMM_DEC5
#define IMM_DEC5 ((int) ((IMMEDIATE < 15) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_DEC6
#define IMM_DEC6 ((int) ((IMMEDIATE < 127) ? IMMEDIATE : -1)) /* scratch - extraction */
#undef IMM_SHIFT_1BIT
#define IMM_SHIFT_1BIT ((int) (IMMEDIATE << 1)) /* scratch - extraction */
#undef IMM_SHIFT_2BIT
#define IMM_SHIFT_2BIT ((int) (IMMEDIATE << 2)) /* scratch - extraction */
#line 6622 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xf,5.0x0,5.RT,16.IMMEDIATE */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3399 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lui r%ld, %#lx", \
                    (long) RT, \
                    (unsigned long) IMMEDIATE);
#line 6645 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LUI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3413 "./mips.igen"
    do_lui (SD_, RT, IMMEDIATE);
  }
#line 6673 "semantics.c"
  return nia;
  /* Extraction: LUI
       #undef do-not-use-icache
       6.0xf,5.0x0,5.RT,16.IMMEDIATE */

#undef RT
#undef IMMEDIATE
#undef TRT
#undef ERT
#undef IMM_DEC1
#undef IMM_DEC2
#undef IMM_DEC3
#undef IMM_DEC4
#undef IMM_DEC5
#undef IMM_DEC6
#undef IMM_SHIFT_1BIT
#undef IMM_SHIFT_2BIT
#line 6691 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_COPz_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_COPz_NORMAL
#undef COPz_NORMAL
#undef MY_PREFIX
#define MY_PREFIX COPz_NORMAL
#undef MY_NAME
#define MY_NAME "COPz_NORMAL"

  /* Extraction: COPz
       #define do-not-use-icache
       4.0x4,2.ZZ!0!1!3,5.COP_FUN0!8,5.COP_FUN1,16.COP_FUN2 */

#undef ZZ
#define ZZ ((unsigned) EXTRACTED32 (instruction_0, 27, 26)) /* cache - extraction */
#undef COP_FUN0
#define COP_FUN0 ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef COP_FUN1
#define COP_FUN1 ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef COP_FUN2
#define COP_FUN2 ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 6720 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 4.0x4,2.ZZ!0!1!3,5.COP_FUN0!8,5.COP_FUN1,16.COP_FUN2 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 6437 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cop%ld %ld%ld%ld", \
                    (long) ZZ, \
                    (long) COP_FUN0, \
                    (long) COP_FUN1, \
                    (long) COP_FUN2);
#line 6740 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_COPz_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 6450 "./mips.igen"
    DecodeCoproc (instruction_0, 2, 0, 0, 0, 0);
  }
#line 6768 "semantics.c"
  return nia;
  /* Extraction: COPz
       #undef do-not-use-icache
       4.0x4,2.ZZ!0!1!3,5.COP_FUN0!8,5.COP_FUN1,16.COP_FUN2 */

#undef ZZ
#undef COP_FUN0
#undef COP_FUN1
#undef COP_FUN2
#line 6778 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MFC0_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MFC0_COP0
#undef MFC0_COP0
#undef MY_PREFIX
#define MY_PREFIX MFC0_COP0
#undef MY_NAME
#define MY_NAME "MFC0_COP0"

  /* Extraction: MFC0
       #define do-not-use-icache
       6.0x10,5.0x0,5.RT,5.RD,8.0x0,3.SEL */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SEL
#define SEL ((unsigned) MASKED32 (instruction_0, 2, 0)) /* cache - extraction */
#undef TRD
#define TRD ((int) ((RD < 2) ? (16 + RD) : RD)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#line 6811 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x0,5.RT,5.RD,8.0x0,3.SEL */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x026007e0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 6383 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mfc0 r%ld, r%ld # %ld", \
                    (long) RT, \
                    (long) RD, \
                    (long) SEL);
#line 6835 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MFC0_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 6397 "./mips.igen"
    TRACE_ALU_INPUT0 ();
    DecodeCoproc (instruction_0, 0, cp0_mfc0, RT, RD, SEL);
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 6865 "semantics.c"
  return nia;
  /* Extraction: MFC0
       #undef do-not-use-icache
       6.0x10,5.0x0,5.RT,5.RD,8.0x0,3.SEL */

#undef RT
#undef RD
#undef SEL
#undef TRD
#undef TRT
#undef ERT
#line 6877 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MTC0_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MTC0_COP0
#undef MTC0_COP0
#undef MY_PREFIX
#define MY_PREFIX MTC0_COP0
#undef MY_NAME
#define MY_NAME "MTC0_COP0"

  /* Extraction: MTC0
       #define do-not-use-icache
       6.0x10,5.0x4,5.RT,5.RD,8.0x0,3.SEL */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SEL
#define SEL ((unsigned) MASKED32 (instruction_0, 2, 0)) /* cache - extraction */
#undef TRD
#define TRD ((int) ((RD < 2) ? (16 + RD) : RD)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#line 6910 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x4,5.RT,5.RD,8.0x0,3.SEL */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x026007e0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 6403 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mtc0 r%ld, r%ld # %ld", \
                    (long) RT, \
                    (long) RD, \
                    (long) SEL);
#line 6934 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MTC0_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 6417 "./mips.igen"
    DecodeCoproc (instruction_0, 0, cp0_mtc0, RT, RD, SEL);
  }
#line 6962 "semantics.c"
  return nia;
  /* Extraction: MTC0
       #undef do-not-use-icache
       6.0x10,5.0x4,5.RT,5.RD,8.0x0,3.SEL */

#undef RT
#undef RD
#undef SEL
#undef TRD
#undef TRT
#undef ERT
#line 6974 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BC0F_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BC0F_COP0
#undef BC0F_COP0
#undef MY_PREFIX
#define MY_PREFIX BC0F_COP0
#undef MY_NAME
#define MY_NAME "BC0F_COP0"

  /* Extraction: BC0F
       #define do-not-use-icache
       6.0x10,5.0x8,5.0x0,16.OFFSET */

#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 6997 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x8,5.0x0,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03fc0000) != 0x01000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 6240 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bc0f %ld", \
                    (long) OFFSET);
#line 7019 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BC0F_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 6239 "./mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:6239:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 7048 "semantics.c"
  return nia;
  /* Extraction: BC0F
       #undef do-not-use-icache
       6.0x10,5.0x8,5.0x0,16.OFFSET */

#undef OFFSET
#line 7055 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BC0T_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BC0T_COP0
#undef BC0T_COP0
#undef MY_PREFIX
#define MY_PREFIX BC0T_COP0
#undef MY_NAME
#define MY_NAME "BC0T_COP0"

  /* Extraction: BC0T
       #define do-not-use-icache
       6.0x10,5.0x8,5.0x1,16.OFFSET */

#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 7078 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x8,5.0x1,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03fc0000) != 0x01000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 6278 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bc0t %ld", \
                    (long) OFFSET);
#line 7100 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BC0T_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 6277 "./mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:6277:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 7129 "semantics.c"
  return nia;
  /* Extraction: BC0T
       #undef do-not-use-icache
       6.0x10,5.0x8,5.0x1,16.OFFSET */

#undef OFFSET
#line 7136 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BC0FL_COP0 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BC0FL_COP0
#undef BC0FL_COP0
#undef MY_PREFIX
#define MY_PREFIX BC0FL_COP0
#undef MY_NAME
#define MY_NAME "BC0FL_COP0"

  /* Extraction: BC0FL
       #define do-not-use-icache
       6.0x10,5.0x8,5.0x2,16.OFFSET */

#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 7159 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x8,5.0x2,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03fc0000) != 0x01000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 6263 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bc0fl %ld", \
                    (long) OFFSET);
#line 7181 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BC0FL_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 6262 "./mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:6262:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 7210 "semantics.c"
  return nia;
  /* Extraction: BC0FL
       #undef do-not-use-icache
       6.0x10,5.0x8,5.0x2,16.OFFSET */

#undef OFFSET
#line 7217 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BC0TL_COP0 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BC0TL_COP0
#undef BC0TL_COP0
#undef MY_PREFIX
#define MY_PREFIX BC0TL_COP0
#undef MY_NAME
#define MY_NAME "BC0TL_COP0"

  /* Extraction: BC0TL
       #define do-not-use-icache
       6.0x10,5.0x8,5.0x3,16.OFFSET */

#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 7240 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x8,5.0x3,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03fc0000) != 0x01000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 6292 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bc0tl %ld", \
                    (long) OFFSET);
#line 7262 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BC0TL_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 6291 "./mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:6291:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 7291 "semantics.c"
  return nia;
  /* Extraction: BC0TL
       #undef do-not-use-icache
       6.0x10,5.0x8,5.0x3,16.OFFSET */

#undef OFFSET
#line 7298 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLBR_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLBR_COP0
#undef TLBR_COP0
#undef MY_PREFIX
#define MY_PREFIX TLBR_COP0
#undef MY_NAME
#define MY_NAME "TLBR_COP0"

  /* Extraction: TLBR
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x1 */

#line 7319 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x1 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 6471 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlbr");
#line 7340 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLBR_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 6470 "./mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:6470:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 7369 "semantics.c"
  return nia;
  /* Extraction: TLBR
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x1 */

#line 7375 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLBWI_COP0 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLBWI_COP0
#undef TLBWI_COP0
#undef MY_PREFIX
#define MY_PREFIX TLBWI_COP0
#undef MY_NAME
#define MY_NAME "TLBWI_COP0"

  /* Extraction: TLBWI
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x2 */

#line 7396 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x2 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 6486 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlbwi");
#line 7417 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLBWI_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 6485 "./mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:6485:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 7446 "semantics.c"
  return nia;
  /* Extraction: TLBWI
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x2 */

#line 7452 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLBWR_COP0 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLBWR_COP0
#undef TLBWR_COP0
#undef MY_PREFIX
#define MY_PREFIX TLBWR_COP0
#undef MY_NAME
#define MY_NAME "TLBWR_COP0"

  /* Extraction: TLBWR
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x6 */

#line 7473 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x6 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 6501 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlbwr");
#line 7494 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLBWR_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 6500 "./mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:6500:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 7523 "semantics.c"
  return nia;
  /* Extraction: TLBWR
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x6 */

#line 7529 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLBP_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLBP_COP0
#undef TLBP_COP0
#undef MY_PREFIX
#define MY_PREFIX TLBP_COP0
#undef MY_NAME
#define MY_NAME "TLBP_COP0"

  /* Extraction: TLBP
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x8 */

#line 7550 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x8 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x00fcffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 6456 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlbp");
#line 7571 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLBP_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 6455 "./mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:6455:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 7600 "semantics.c"
  return nia;
  /* Extraction: TLBP
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x8 */

#line 7606 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_RFE_COP0 (SIM_DESC sd,
                   instruction_word instruction_0,
                   instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_RFE_COP0
#undef RFE_COP0
#undef MY_PREFIX
#define MY_PREFIX RFE_COP0
#undef MY_NAME
#define MY_NAME "RFE_COP0"

  /* Extraction: RFE
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x10 */

#line 7627 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x10 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x00fcffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 6422 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "rfe");
#line 7648 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_RFE_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 6432 "./mips.igen"
    DecodeCoproc (instruction_0, 0, cp0_rfe, 0, 0, 0x10);
  }
#line 7676 "semantics.c"
  return nia;
  /* Extraction: RFE
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x10 */

#line 7682 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ERET_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ERET_COP0
#undef ERET_COP0
#undef MY_PREFIX
#define MY_PREFIX ERET_COP0
#undef MY_NAME
#define MY_NAME "ERET_COP0"

  /* Extraction: ERET
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x18 */

#line 7703 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x18 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x00fcffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 6356 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "eret");
#line 7724 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ERET_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 6367 "./mips.igen"
    if (SR & status_ERL)
      {
        /* Oops, not yet available */
        sim_io_printf (SD, "Warning: ERET when SR[ERL] set not supported");
        NIA = EPC;
        SR &= ~status_ERL;
      }
    else
      {
        NIA = EPC;
        SR &= ~status_EXL;
      }
  }
#line 7763 "semantics.c"
  return nia;
  /* Extraction: ERET
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x18 */

#line 7769 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MFC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MFC1b_COP1
#undef MFC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX MFC1b_COP1
#undef MY_NAME
#define MY_NAME "MFC1b_COP1"

  /* Extraction: MFC1b
       #define do-not-use-icache
       6.0x11,5.0x0,5.RT,5.FS,11.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#line 7800 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x0,5.RT,5.FS,11.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5734 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mfc1 r%ld, f%ld", \
                    (long) RT, \
                    (long) FS);
#line 7837 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MFC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5745 "./mips.igen"
    do_mfc1b (SD_, RT, FS);
  }
#line 7865 "semantics.c"
  return nia;
  /* Extraction: MFC1b
       #undef do-not-use-icache
       6.0x11,5.0x0,5.RT,5.FS,11.0x0 */

#undef RT
#undef FS
#undef SFRAME
#undef TRT
#undef ERT
#line 7876 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CFC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CFC1b_COP1
#undef CFC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX CFC1b_COP1
#undef MY_NAME
#define MY_NAME "CFC1b_COP1"

  /* Extraction: CFC1b
       #define do-not-use-icache
       6.0x11,5.0x2,5.RT,5.FS,11.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#line 7907 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x2,5.RT,5.FS,11.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5305 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cfc1 r%ld, f%ld", \
                    (long) RT, \
                    (long) FS);
#line 7944 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CFC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5311 "./mips.igen"
    check_fpu (SD_);
    if (FS == 0 || FS == 31)
      {
        unsigned_word  fcr = ValueFCR (FS);
        TRACE_ALU_INPUT1 (fcr);
        GPR[RT] = fcr;
      }
    /* else NOP */
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 7980 "semantics.c"
  return nia;
  /* Extraction: CFC1b
       #undef do-not-use-icache
       6.0x11,5.0x2,5.RT,5.FS,11.0x0 */

#undef RT
#undef FS
#undef SFRAME
#undef TRT
#undef ERT
#line 7991 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MTC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MTC1b_COP1
#undef MTC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX MTC1b_COP1
#undef MY_NAME
#define MY_NAME "MTC1b_COP1"

  /* Extraction: MTC1b
       #define do-not-use-icache
       6.0x11,5.0x4,5.RT,5.FS,11.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#line 8022 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x4,5.RT,5.FS,11.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5863 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mtc1 r%ld, f%ld", \
                    (long) RT, \
                    (long) FS);
#line 8059 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MTC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5874 "./mips.igen"
    do_mtc1b (SD_, RT, FS);
  }
#line 8087 "semantics.c"
  return nia;
  /* Extraction: MTC1b
       #undef do-not-use-icache
       6.0x11,5.0x4,5.RT,5.FS,11.0x0 */

#undef RT
#undef FS
#undef SFRAME
#undef TRT
#undef ERT
#line 8098 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CTC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CTC1b_COP1
#undef CTC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX CTC1b_COP1
#undef MY_NAME
#define MY_NAME "CTC1b_COP1"

  /* Extraction: CTC1b
       #define do-not-use-icache
       6.0x11,5.0x6,5.RT,5.FS,11.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#line 8129 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x6,5.RT,5.FS,11.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5346 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ctc1 r%ld, f%ld", \
                    (long) RT, \
                    (long) FS);
#line 8166 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CTC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5352 "./mips.igen"
    check_fpu (SD_);
    TRACE_ALU_INPUT1 (GPR[RT]);
    if (FS == 31)
      StoreFCR (FS, GPR[RT]);
    /* else NOP */
  }
#line 8198 "semantics.c"
  return nia;
  /* Extraction: CTC1b
       #undef do-not-use-icache
       6.0x11,5.0x6,5.RT,5.FS,11.0x0 */

#undef RT
#undef FS
#undef SFRAME
#undef TRT
#undef ERT
#line 8209 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BC1b_COP1S (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BC1b_COP1S
#undef BC1b_COP1S
#undef MY_PREFIX
#define MY_PREFIX BC1b_COP1S
#undef MY_NAME
#define MY_NAME "BC1b_COP1S"

  /* Extraction: BC1b
       #define do-not-use-icache
       6.0x11,5.0x8,3.CC,1.ND,1.TF,16.OFFSET */

#undef CC
#define CC ((unsigned) EXTRACTED32 (instruction_0, 20, 18)) /* cache - extraction */
#undef ND
#define ND ((unsigned) EXTRACTED32 (instruction_0, 17, 17)) /* cache - extraction */
#undef TF
#define TF ((unsigned) EXTRACTED32 (instruction_0, 16, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 8238 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x8,3.CC,1.ND,1.TF,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x01000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
      if (CC == 0)
#line 5202 "./mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "bc1%s%s %ld", \
                      str_TF (SD_, TF), \
                      str_ND (SD_, ND), \
                      (long) OFFSET);
#line 8277 "semantics.c"
      else
#line 5203 "./mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "bc1%s%s %ld, %ld", \
                      str_TF (SD_, TF), \
                      str_ND (SD_, ND), \
                      (long) CC, \
                      (long) OFFSET);
#line 8288 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BC1b_COP1S, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5214 "./mips.igen"
    check_fpu (SD_);
    if (GETFCC(CC) == TF)
      {
        address_word dest = NIA + (EXTEND16 (OFFSET) << 2);
        DELAY_SLOT (dest);
      }
    else if (ND)
      {
        NULLIFY_NEXT_INSTRUCTION ();
      }
  }
#line 8325 "semantics.c"
  return nia;
  /* Extraction: BC1b
       #undef do-not-use-icache
       6.0x11,5.0x8,3.CC,1.ND,1.TF,16.OFFSET */

#undef CC
#undef ND
#undef TF
#undef OFFSET
#line 8335 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ADD_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ADD_fmt_COP1
#undef ADD_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX ADD_fmt_COP1
#undef MY_NAME
#define MY_NAME "ADD_fmt_COP1"

  /* Extraction: ADD.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.FT,5.FS,5.FD,6.0x0 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8366 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.FT,5.FS,5.FD,6.0x0 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5142 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "add.%s f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) FT);
#line 8400 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ADD_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5156 "./mips.igen"
    do_add_fmt (SD_, FMT, FD, FS, FT, instruction_0);
  }
#line 8428 "semantics.c"
  return nia;
  /* Extraction: ADD.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.FT,5.FS,5.FD,6.0x0 */

#undef FMT
#undef FT
#undef FS
#undef FD
#undef SFRAME
#line 8439 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SUB_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SUB_fmt_COP1
#undef SUB_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX SUB_fmt_COP1
#undef MY_NAME
#define MY_NAME "SUB_fmt_COP1"

  /* Extraction: SUB.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.FT,5.FS,5.FD,6.0x1 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8470 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.FT,5.FS,5.FD,6.0x1 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 6147 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sub.%s f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) FT);
#line 8504 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SUB_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 6161 "./mips.igen"
    do_sub_fmt (SD_, FMT, FD, FS, FT, instruction_0);
  }
#line 8532 "semantics.c"
  return nia;
  /* Extraction: SUB.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.FT,5.FS,5.FD,6.0x1 */

#undef FMT
#undef FT
#undef FS
#undef FD
#undef SFRAME
#line 8543 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MUL_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MUL_fmt_COP1
#undef MUL_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX MUL_fmt_COP1
#undef MY_NAME
#define MY_NAME "MUL_fmt_COP1"

  /* Extraction: MUL.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.FT,5.FS,5.FD,6.0x2 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8574 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.FT,5.FS,5.FD,6.0x2 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5879 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mul.%s f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) FT);
#line 8608 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MUL_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5893 "./mips.igen"
    do_mul_fmt (SD_, FMT, FD, FS, FT, instruction_0);
  }
#line 8636 "semantics.c"
  return nia;
  /* Extraction: MUL.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.FT,5.FS,5.FD,6.0x2 */

#undef FMT
#undef FT
#undef FS
#undef FD
#undef SFRAME
#line 8647 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DIV_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DIV_fmt_COP1
#undef DIV_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX DIV_fmt_COP1
#undef MY_NAME
#define MY_NAME "DIV_fmt_COP1"

  /* Extraction: DIV.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.FT,5.FS,5.FD,6.0x3 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8678 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.FT,5.FS,5.FD,6.0x3 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5484 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "div.%s f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) FT);
#line 8712 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DIV_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5498 "./mips.igen"
    do_div_fmt (SD_, FMT, FD, FS, FT, instruction_0);
  }
#line 8740 "semantics.c"
  return nia;
  /* Extraction: DIV.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.FT,5.FS,5.FD,6.0x3 */

#undef FMT
#undef FT
#undef FS
#undef FD
#undef SFRAME
#line 8751 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVZ_fmt_COP1 (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVZ_fmt_COP1
#undef MOVZ_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX MOVZ_fmt_COP1
#undef MY_NAME
#define MY_NAME "MOVZ_fmt_COP1"

  /* Extraction: MOVZ.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.RT,5.FS,5.FD,6.0x12 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#line 8786 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.RT,5.FS,5.FD,6.0x12 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5822 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "movz.%s f%ld, f%ld, r%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) RT);
#line 8820 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVZ_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5831 "./mips.igen"
    do_movz_fmt (SD_, FMT, FD, FS, RT);
  }
#line 8848 "semantics.c"
  return nia;
  /* Extraction: MOVZ.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.RT,5.FS,5.FD,6.0x12 */

#undef FMT
#undef RT
#undef FS
#undef FD
#undef SFRAME
#undef TRT
#undef ERT
#line 8861 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVN_fmt_COP1 (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVN_fmt_COP1
#undef MOVN_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX MOVN_fmt_COP1
#undef MY_NAME
#define MY_NAME "MOVN_fmt_COP1"

  /* Extraction: MOVN.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.RT,5.FS,5.FD,6.0x13 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#line 8896 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.RT,5.FS,5.FD,6.0x13 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5801 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "movn.%s f%ld, f%ld, r%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) RT);
#line 8930 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVN_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5810 "./mips.igen"
    do_movn_fmt (SD_, FMT, FD, FS, RT);
  }
#line 8958 "semantics.c"
  return nia;
  /* Extraction: MOVN.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.RT,5.FS,5.FD,6.0x13 */

#undef FMT
#undef RT
#undef FS
#undef FD
#undef SFRAME
#undef TRT
#undef ERT
#line 8971 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_C_cond_fmtb_COP1 (SIM_DESC sd,
                           instruction_word instruction_0,
                           instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_C_cond_fmtb_COP1
#undef C_cond_fmtb_COP1
#undef MY_PREFIX
#define MY_PREFIX C_cond_fmtb_COP1
#undef MY_NAME
#define MY_NAME "C_cond_fmtb_COP1"

  /* Extraction: C.cond.fmtb
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.FT,5.FS,3.CC,2.0x0,2.0x3,4.COND */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef CC
#define CC ((unsigned) EXTRACTED32 (instruction_0, 10, 8)) /* cache - extraction */
#undef COND
#define COND ((unsigned) MASKED32 (instruction_0, 3, 0)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9004 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.FT,5.FS,3.CC,2.0x0,2.0x3,4.COND */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000000c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
      if (CC == 0)
#line 5240 "./mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "c.%s.%s f%ld, f%ld", \
                      str_COND (SD_, COND), \
                      str_FMT (SD_, FMT), \
                      (long) FS, \
                      (long) FT);
#line 9044 "semantics.c"
      else
#line 5241 "./mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "c.%s.%s %ld, f%ld, f%ld", \
                      str_COND (SD_, COND), \
                      str_FMT (SD_, FMT), \
                      (long) CC, \
                      (long) FS, \
                      (long) FT);
#line 9056 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_C_cond_fmtb_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5252 "./mips.igen"
    do_c_cond_fmt (SD_, COND, FMT, CC, FS, FT, instruction_0);
  }
#line 9084 "semantics.c"
  return nia;
  /* Extraction: C.cond.fmtb
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.FT,5.FS,3.CC,2.0x0,2.0x3,4.COND */

#undef FMT
#undef FT
#undef FS
#undef CC
#undef COND
#undef SFRAME
#line 9096 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVtf_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVtf_fmt_COP1
#undef MOVtf_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX MOVtf_fmt_COP1
#undef MY_NAME
#define MY_NAME "MOVtf_fmt_COP1"

  /* Extraction: MOVtf.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,3.CC,1.0x0,1.TF,5.FS,5.FD,6.0x11 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef CC
#define CC ((unsigned) EXTRACTED32 (instruction_0, 20, 18)) /* cache - extraction */
#undef TF
#define TF ((unsigned) EXTRACTED32 (instruction_0, 16, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9129 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!7,3.CC,1.0x0,1.TF,5.FS,5.FD,6.0x11 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x00020000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5787 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mov%s.%s f%ld, f%ld, %ld", \
                    str_TF (SD_, TF), \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) CC);
#line 9169 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVtf_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5796 "./mips.igen"
    do_movtf_fmt (SD_, TF, FMT, FD, FS, CC);
  }
#line 9197 "semantics.c"
  return nia;
  /* Extraction: MOVtf.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,3.CC,1.0x0,1.TF,5.FS,5.FD,6.0x11 */

#undef FMT
#undef CC
#undef TF
#undef FS
#undef FD
#undef SFRAME
#line 9209 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SQRT_fmt_COP1 (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SQRT_fmt_COP1
#undef SQRT_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX SQRT_fmt_COP1
#undef MY_NAME
#define MY_NAME "SQRT_fmt_COP1"

  /* Extraction: SQRT.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x4 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9238 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x4 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 6129 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sqrt.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9276 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SQRT_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 6142 "./mips.igen"
    do_sqrt_fmt (SD_, FMT, FD, FS);
  }
#line 9304 "semantics.c"
  return nia;
  /* Extraction: SQRT.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x4 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 9314 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ABS_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ABS_fmt_COP1
#undef ABS_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX ABS_fmt_COP1
#undef MY_NAME
#define MY_NAME "ABS_fmt_COP1"

  /* Extraction: ABS.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.0x0,5.FS,5.FD,6.0x5 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9343 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.0x0,5.FS,5.FD,6.0x5 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5122 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "abs.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9381 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ABS_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5136 "./mips.igen"
    do_abs_fmt (SD_, FMT, FD, FS, instruction_0);
  }
#line 9409 "semantics.c"
  return nia;
  /* Extraction: ABS.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.0x0,5.FS,5.FD,6.0x5 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 9419 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOV_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOV_fmt_COP1
#undef MOV_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX MOV_fmt_COP1
#undef MY_NAME
#define MY_NAME "MOV_fmt_COP1"

  /* Extraction: MOV.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.0x0,5.FS,5.FD,6.0x6 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9448 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.0x0,5.FS,5.FD,6.0x6 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5750 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mov.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9486 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOV_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5764 "./mips.igen"
    do_mov_fmt (SD_, FMT, FD, FS, instruction_0);
  }
#line 9514 "semantics.c"
  return nia;
  /* Extraction: MOV.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.0x0,5.FS,5.FD,6.0x6 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 9524 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_NEG_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_NEG_fmt_COP1
#undef NEG_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX NEG_fmt_COP1
#undef MY_NAME
#define MY_NAME "NEG_fmt_COP1"

  /* Extraction: NEG.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.0x0,5.FS,5.FD,6.0x7 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9553 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.0x0,5.FS,5.FD,6.0x7 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5898 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "neg.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9591 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_NEG_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5912 "./mips.igen"
    do_neg_fmt (SD_, FMT, FD, FS, instruction_0);
  }
#line 9619 "semantics.c"
  return nia;
  /* Extraction: NEG.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.0x0,5.FS,5.FD,6.0x7 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 9629 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ROUND_L_fmt_COP1 (SIM_DESC sd,
                           instruction_word instruction_0,
                           instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ROUND_L_fmt_COP1
#undef ROUND_L_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX ROUND_L_fmt_COP1
#undef MY_NAME
#define MY_NAME "ROUND_L_fmt_COP1"

  /* Extraction: ROUND.L.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x8 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9658 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x8 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 6013 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "round.l.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9696 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ROUND_L_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 6024 "./mips.igen"
    do_round_fmt (SD_, fmt_long, FMT, FD, FS);
  }
#line 9724 "semantics.c"
  return nia;
  /* Extraction: ROUND.L.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x8 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 9734 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TRUNC_L_fmt_COP1 (SIM_DESC sd,
                           instruction_word instruction_0,
                           instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TRUNC_L_fmt_COP1
#undef TRUNC_L_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX TRUNC_L_fmt_COP1
#undef MY_NAME
#define MY_NAME "TRUNC_L_fmt_COP1"

  /* Extraction: TRUNC.L.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x9 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9763 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x9 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 6199 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "trunc.l.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9801 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TRUNC_L_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 6210 "./mips.igen"
    do_trunc_fmt (SD_, fmt_long, FMT, FD, FS);
  }
#line 9829 "semantics.c"
  return nia;
  /* Extraction: TRUNC.L.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x9 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 9839 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CEIL_L_fmt_COP1 (SIM_DESC sd,
                          instruction_word instruction_0,
                          instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CEIL_L_fmt_COP1
#undef CEIL_L_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX CEIL_L_fmt_COP1
#undef MY_NAME
#define MY_NAME "CEIL_L_fmt_COP1"

  /* Extraction: CEIL.L.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xa */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9868 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xa */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5257 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ceil.l.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 9906 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CEIL_L_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5268 "./mips.igen"
    do_ceil_fmt (SD_, fmt_long, FMT, FD, FS, instruction_0);
  }
#line 9934 "semantics.c"
  return nia;
  /* Extraction: CEIL.L.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xa */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 9944 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_FLOOR_L_fmt_COP1 (SIM_DESC sd,
                           instruction_word instruction_0,
                           instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_FLOOR_L_fmt_COP1
#undef FLOOR_L_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX FLOOR_L_fmt_COP1
#undef MY_NAME
#define MY_NAME "FLOOR_L_fmt_COP1"

  /* Extraction: FLOOR.L.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xb */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9973 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xb */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5571 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "floor.l.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 10011 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_FLOOR_L_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5582 "./mips.igen"
    do_floor_fmt (SD_, fmt_long, FMT, FD, FS);
  }
#line 10039 "semantics.c"
  return nia;
  /* Extraction: FLOOR.L.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xb */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 10049 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ROUND_W_fmt_COP1 (SIM_DESC sd,
                           instruction_word instruction_0,
                           instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ROUND_W_fmt_COP1
#undef ROUND_W_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX ROUND_W_fmt_COP1
#undef MY_NAME
#define MY_NAME "ROUND_W_fmt_COP1"

  /* Extraction: ROUND.W.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xc */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 10078 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xc */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 6029 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "round.w.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 10116 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ROUND_W_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 6042 "./mips.igen"
    do_round_fmt (SD_, fmt_word, FMT, FD, FS);
  }
#line 10144 "semantics.c"
  return nia;
  /* Extraction: ROUND.W.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xc */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 10154 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TRUNC_W_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TRUNC_W_COP1
#undef TRUNC_W_COP1
#undef MY_PREFIX
#define MY_PREFIX TRUNC_W_COP1
#undef MY_NAME
#define MY_NAME "TRUNC_W_COP1"

  /* Extraction: TRUNC.W
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xd */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 10183 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xd */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 6215 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "trunc.w.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 10221 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TRUNC_W_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 6228 "./mips.igen"
    do_trunc_fmt (SD_, fmt_word, FMT, FD, FS);
  }
#line 10249 "semantics.c"
  return nia;
  /* Extraction: TRUNC.W
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xd */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 10259 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CEIL_W_COP1 (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CEIL_W_COP1
#undef CEIL_W_COP1
#undef MY_PREFIX
#define MY_PREFIX CEIL_W_COP1
#undef MY_NAME
#define MY_NAME "CEIL_W_COP1"

  /* Extraction: CEIL.W
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xe */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 10288 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xe */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5273 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ceil.w.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 10326 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CEIL_W_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5286 "./mips.igen"
    do_ceil_fmt (SD_, fmt_word, FMT, FD, FS, instruction_0);
  }
#line 10354 "semantics.c"
  return nia;
  /* Extraction: CEIL.W
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xe */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 10364 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_FLOOR_W_fmt_COP1 (SIM_DESC sd,
                           instruction_word instruction_0,
                           instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_FLOOR_W_fmt_COP1
#undef FLOOR_W_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX FLOOR_W_fmt_COP1
#undef MY_NAME
#define MY_NAME "FLOOR_W_fmt_COP1"

  /* Extraction: FLOOR.W.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xf */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 10393 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xf */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5587 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "floor.w.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 10431 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_FLOOR_W_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5600 "./mips.igen"
    do_floor_fmt (SD_, fmt_word, FMT, FD, FS);
  }
#line 10459 "semantics.c"
  return nia;
  /* Extraction: FLOOR.W.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xf */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 10469 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_RECIP_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_RECIP_fmt_COP1
#undef RECIP_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX RECIP_fmt_COP1
#undef MY_NAME
#define MY_NAME "RECIP_fmt_COP1"

  /* Extraction: RECIP.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x15 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 10498 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x15 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 6000 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "recip.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 10536 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_RECIP_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 6008 "./mips.igen"
    do_recip_fmt (SD_, FMT, FD, FS);
  }
#line 10564 "semantics.c"
  return nia;
  /* Extraction: RECIP.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x15 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 10574 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_RSQRT_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_RSQRT_fmt_COP1
#undef RSQRT_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX RSQRT_fmt_COP1
#undef MY_NAME
#define MY_NAME "RSQRT_fmt_COP1"

  /* Extraction: RSQRT.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x16 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 10603 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x16 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 6047 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "rsqrt.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 10641 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_RSQRT_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 6055 "./mips.igen"
    do_rsqrt_fmt (SD_, FMT, FD, FS);
  }
#line 10669 "semantics.c"
  return nia;
  /* Extraction: RSQRT.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x16 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 10679 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CVT_S_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CVT_S_fmt_COP1
#undef CVT_S_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX CVT_S_fmt_COP1
#undef MY_NAME
#define MY_NAME "CVT_S_fmt_COP1"

  /* Extraction: CVT.S.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!0!2!3!6!7,5.0x0,5.FS,5.FD,6.0x20 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 10708 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!0!2!3!6!7,5.0x0,5.FS,5.FD,6.0x20 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5424 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cvt.s.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 10746 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CVT_S_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5438 "./mips.igen"
    do_cvt_s_fmt (SD_, FMT, FD, FS, instruction_0);
  }
#line 10774 "semantics.c"
  return nia;
  /* Extraction: CVT.S.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!0!2!3!6!7,5.0x0,5.FS,5.FD,6.0x20 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 10784 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CVT_D_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CVT_D_fmt_COP1
#undef CVT_D_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX CVT_D_fmt_COP1
#undef MY_NAME
#define MY_NAME "CVT_D_fmt_COP1"

  /* Extraction: CVT.D.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!1!2!3!6!7,5.0x0,5.FS,5.FD,6.0x21 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 10813 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!1!2!3!6!7,5.0x0,5.FS,5.FD,6.0x21 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5375 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cvt.d.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 10851 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CVT_D_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5389 "./mips.igen"
    do_cvt_d_fmt (SD_, FMT, FD, FS, instruction_0);
  }
#line 10879 "semantics.c"
  return nia;
  /* Extraction: CVT.D.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!1!2!3!6!7,5.0x0,5.FS,5.FD,6.0x21 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 10889 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CVT_W_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CVT_W_fmt_COP1
#undef CVT_W_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX CVT_W_fmt_COP1
#undef MY_NAME
#define MY_NAME "CVT_W_fmt_COP1"

  /* Extraction: CVT.W.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x24 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 10918 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x24 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5465 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cvt.w.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 10956 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CVT_W_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5479 "./mips.igen"
    do_cvt_w_fmt (SD_, FMT, FD, FS, instruction_0);
  }
#line 10984 "semantics.c"
  return nia;
  /* Extraction: CVT.W.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x24 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 10994 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CVT_L_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CVT_L_fmt_COP1
#undef CVT_L_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX CVT_L_fmt_COP1
#undef MY_NAME
#define MY_NAME "CVT_L_fmt_COP1"

  /* Extraction: CVT.L.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x25 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 11023 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x25 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5394 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cvt.l.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 11061 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CVT_L_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5405 "./mips.igen"
    do_cvt_l_fmt (SD_, FMT, FD, FS, instruction_0);
  }
#line 11089 "semantics.c"
  return nia;
  /* Extraction: CVT.L.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x25 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 11099 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MADD_fmt_COP1X (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MADD_fmt_COP1X
#undef MADD_fmt_COP1X
#undef MY_PREFIX
#define MY_PREFIX MADD_fmt_COP1X
#undef MY_NAME
#define MY_NAME "MADD_fmt_COP1X"

  /* Extraction: MADD.fmt
       #define do-not-use-icache
       6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x4,3.FMT!2!3!4!5!7 */

#undef FR
#define FR ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef FMT
#define FMT ((unsigned) MASKED32 (instruction_0, 2, 0)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 11132 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x4,3.FMT!2!3!4!5!7 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5708 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "madd.%s f%ld, f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FR, \
                    (long) FS, \
                    (long) FT);
#line 11167 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MADD_fmt_COP1X, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5716 "./mips.igen"
    do_madd_fmt (SD_, FMT, FD, FR, FS, FT, instruction_0);
  }
#line 11195 "semantics.c"
  return nia;
  /* Extraction: MADD.fmt
       #undef do-not-use-icache
       6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x4,3.FMT!2!3!4!5!7 */

#undef FR
#undef FT
#undef FS
#undef FD
#undef FMT
#undef SFRAME
#line 11207 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MSUB_fmt_COP1X (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MSUB_fmt_COP1X
#undef MSUB_fmt_COP1X
#undef MY_PREFIX
#define MY_PREFIX MSUB_fmt_COP1X
#undef MY_NAME
#define MY_NAME "MSUB_fmt_COP1X"

  /* Extraction: MSUB.fmt
       #define do-not-use-icache
       6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x5,3.FMT!2!3!4!5!7 */

#undef FR
#define FR ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef FMT
#define FMT ((unsigned) MASKED32 (instruction_0, 2, 0)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 11240 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x5,3.FMT!2!3!4!5!7 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5836 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "msub.%s f%ld, f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FR, \
                    (long) FS, \
                    (long) FT);
#line 11275 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MSUB_fmt_COP1X, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5844 "./mips.igen"
    do_msub_fmt (SD_, FMT, FD, FR, FS, FT, instruction_0);
  }
#line 11303 "semantics.c"
  return nia;
  /* Extraction: MSUB.fmt
       #undef do-not-use-icache
       6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x5,3.FMT!2!3!4!5!7 */

#undef FR
#undef FT
#undef FS
#undef FD
#undef FMT
#undef SFRAME
#line 11315 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_NMADD_fmt_COP1X (SIM_DESC sd,
                          instruction_word instruction_0,
                          instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_NMADD_fmt_COP1X
#undef NMADD_fmt_COP1X
#undef MY_PREFIX
#define MY_PREFIX NMADD_fmt_COP1X
#undef MY_NAME
#define MY_NAME "NMADD_fmt_COP1X"

  /* Extraction: NMADD.fmt
       #define do-not-use-icache
       6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x6,3.FMT!2!3!4!5!7 */

#undef FR
#define FR ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef FMT
#define FMT ((unsigned) MASKED32 (instruction_0, 2, 0)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 11348 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x6,3.FMT!2!3!4!5!7 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5917 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "nmadd.%s f%ld, f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FR, \
                    (long) FS, \
                    (long) FT);
#line 11383 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_NMADD_fmt_COP1X, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5925 "./mips.igen"
    do_nmadd_fmt (SD_, FMT, FD, FR, FS, FT, instruction_0);
  }
#line 11411 "semantics.c"
  return nia;
  /* Extraction: NMADD.fmt
       #undef do-not-use-icache
       6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x6,3.FMT!2!3!4!5!7 */

#undef FR
#undef FT
#undef FS
#undef FD
#undef FMT
#undef SFRAME
#line 11423 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_NMSUB_fmt_COP1X (SIM_DESC sd,
                          instruction_word instruction_0,
                          instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_NMSUB_fmt_COP1X
#undef NMSUB_fmt_COP1X
#undef MY_PREFIX
#define MY_PREFIX NMSUB_fmt_COP1X
#undef MY_NAME
#define MY_NAME "NMSUB_fmt_COP1X"

  /* Extraction: NMSUB.fmt
       #define do-not-use-icache
       6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x7,3.FMT!2!3!4!5!7 */

#undef FR
#define FR ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef FMT
#define FMT ((unsigned) MASKED32 (instruction_0, 2, 0)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 11456 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x7,3.FMT!2!3!4!5!7 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5930 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "nmsub.%s f%ld, f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FR, \
                    (long) FS, \
                    (long) FT);
#line 11491 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_NMSUB_fmt_COP1X, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5938 "./mips.igen"
    do_nmsub_fmt (SD_, FMT, FD, FR, FS, FT, instruction_0);
  }
#line 11519 "semantics.c"
  return nia;
  /* Extraction: NMSUB.fmt
       #undef do-not-use-icache
       6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x7,3.FMT!2!3!4!5!7 */

#undef FR
#undef FT
#undef FS
#undef FD
#undef FMT
#undef SFRAME
#line 11531 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SWXC1_COP1X (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SWXC1_COP1X
#undef SWXC1_COP1X
#undef MY_PREFIX
#define MY_PREFIX SWXC1_COP1X
#undef MY_NAME
#define MY_NAME "SWXC1_COP1X"

  /* Extraction: SWXC1
       #define do-not-use-icache
       6.0x13,5.BASE,5.INDEX,5.FS,5.0x0,6.0x8 */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef INDEX
#define INDEX ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#undef TBASE
#define TBASE ((int) ((BASE < 2) ? (16 + BASE) : BASE)) /* scratch - extraction */
#line 11562 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x13,5.BASE,5.INDEX,5.FS,5.0x0,6.0x8 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 6186 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "swxc1 f%ld, r%ld(r%ld)", \
                    (long) FS, \
                    (long) INDEX, \
                    (long) BASE);
#line 11600 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SWXC1_COP1X, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 6194 "./mips.igen"
    do_swxc1 (SD_, FS, INDEX, BASE, instruction_0);
  }
#line 11628 "semantics.c"
  return nia;
  /* Extraction: SWXC1
       #undef do-not-use-icache
       6.0x13,5.BASE,5.INDEX,5.FS,5.0x0,6.0x8 */

#undef BASE
#undef INDEX
#undef FS
#undef SFRAME
#undef TBASE
#line 11639 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_PREFX_COP1X (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_PREFX_COP1X
#undef PREFX_COP1X
#undef MY_PREFIX
#define MY_PREFIX PREFX_COP1X
#undef MY_NAME
#define MY_NAME "PREFX_COP1X"

  /* Extraction: PREFX
       #define do-not-use-icache
       6.0x13,5.BASE,5.INDEX,5.HINT,5.0x0,6.0xf */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef INDEX
#define INDEX ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef HINT
#define HINT ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef TBASE
#define TBASE ((int) ((BASE < 2) ? (16 + BASE) : BASE)) /* scratch - extraction */
#line 11668 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x13,5.BASE,5.INDEX,5.HINT,5.0x0,6.0xf */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5965 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "prefx %ld, r%ld(r%ld)", \
                    (long) HINT, \
                    (long) INDEX, \
                    (long) BASE);
#line 11692 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_PREFX_COP1X, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5973 "./mips.igen"
    do_prefx (SD_, HINT, INDEX, BASE);
  }
#line 11720 "semantics.c"
  return nia;
  /* Extraction: PREFX
       #undef do-not-use-icache
       6.0x13,5.BASE,5.INDEX,5.HINT,5.0x0,6.0xf */

#undef BASE
#undef INDEX
#undef HINT
#undef TBASE
#line 11730 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LWXC1_COP1X (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LWXC1_COP1X
#undef LWXC1_COP1X
#undef MY_PREFIX
#define MY_PREFIX LWXC1_COP1X
#undef MY_NAME
#define MY_NAME "LWXC1_COP1X"

  /* Extraction: LWXC1
       #define do-not-use-icache
       6.0x13,5.BASE,5.INDEX,5.0x0,5.FD,6.0x0 */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef INDEX
#define INDEX ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef TBASE
#define TBASE ((int) ((BASE < 2) ? (16 + BASE) : BASE)) /* scratch - extraction */
#line 11759 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x13,5.BASE,5.INDEX,5.0x0,5.FD,6.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000f800) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5694 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lwxc1 f%ld, r%ld(r%ld)", \
                    (long) FD, \
                    (long) INDEX, \
                    (long) BASE);
#line 11797 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LWXC1_COP1X, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5702 "./mips.igen"
    do_lwxc1 (SD_, FD, INDEX, BASE, instruction_0);
  }
#line 11825 "semantics.c"
  return nia;
  /* Extraction: LWXC1
       #undef do-not-use-icache
       6.0x13,5.BASE,5.INDEX,5.0x0,5.FD,6.0x0 */

#undef BASE
#undef INDEX
#undef FD
#undef TBASE
#line 11835 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BEQL_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BEQL_NORMAL
#undef BEQL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BEQL_NORMAL
#undef MY_NAME
#define MY_NAME "BEQL_NORMAL"

  /* Extraction: BEQL
       #define do-not-use-icache
       6.0x14,5.RS,5.RT,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 11870 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x14,5.RS,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1926 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "beql r%ld, r%ld, %ld", \
                    (long) RS, \
                    (long) RT, \
                    (long) OFFSET);
#line 11889 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BEQL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1939 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] == (signed_word) GPR[RT])
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 11923 "semantics.c"
  return nia;
  /* Extraction: BEQL
       #undef do-not-use-icache
       6.0x14,5.RS,5.RT,16.OFFSET */

#undef RS
#undef RT
#undef OFFSET
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 11936 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BNEL_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BNEL_NORMAL
#undef BNEL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BNEL_NORMAL
#undef MY_NAME
#define MY_NAME "BNEL_NORMAL"

  /* Extraction: BNEL
       #define do-not-use-icache
       6.0x15,5.RS,5.RT,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 11971 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x15,5.RS,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2291 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bnel r%ld, r%ld, %ld", \
                    (long) RS, \
                    (long) RT, \
                    (long) OFFSET);
#line 11990 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BNEL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2304 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] != (signed_word) GPR[RT])
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 12024 "semantics.c"
  return nia;
  /* Extraction: BNEL
       #undef do-not-use-icache
       6.0x15,5.RS,5.RT,16.OFFSET */

#undef RS
#undef RT
#undef OFFSET
#undef TRS
#undef TRT
#undef ERT
#undef ERS
#line 12037 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLEZL_NORMAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLEZL_NORMAL
#undef BLEZL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BLEZL_NORMAL
#undef MY_NAME
#define MY_NAME "BLEZL_NORMAL"

  /* Extraction: BLEZL
       #define do-not-use-icache
       6.0x16,5.RS,5.0x0,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 12066 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x16,5.RS,5.0x0,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2134 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgezl r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 12089 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLEZL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2147 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] <= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 12123 "semantics.c"
  return nia;
  /* Extraction: BLEZL
       #undef do-not-use-icache
       6.0x16,5.RS,5.0x0,16.OFFSET */

#undef RS
#undef OFFSET
#undef TRS
#undef ERS
#line 12133 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGTZL_NORMAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGTZL_NORMAL
#undef BGTZL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BGTZL_NORMAL
#undef MY_NAME
#define MY_NAME "BGTZL_NORMAL"

  /* Extraction: BGTZL
       #define do-not-use-icache
       6.0x17,5.RS,5.0x0,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TRS
#define TRS ((int) ((RS < 2) ? (16 + RS) : RS)) /* scratch - extraction */
#undef ERS
#define ERS ((int) (compute_movep_src_reg (SD_, RS))) /* scratch - extraction */
#line 12162 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x17,5.RS,5.0x0,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2081 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgtzl r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 12185 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGTZL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2094 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    /* NOTE: The branch occurs AFTER the next instruction has been
       executed */
    if ((signed_word) GPR[RS] > 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 12221 "semantics.c"
  return nia;
  /* Extraction: BGTZL
       #undef do-not-use-icache
       6.0x17,5.RS,5.0x0,16.OFFSET */

#undef RS
#undef OFFSET
#undef TRS
#undef ERS
#line 12231 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LB_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LB_NORMAL
#undef LB_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LB_NORMAL
#undef MY_NAME
#define MY_NAME "LB_NORMAL"

  /* Extraction: LB
       #define do-not-use-icache
       6.0x20,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TBASE
#define TBASE ((int) ((BASE < 2) ? (16 + BASE) : BASE)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#line 12264 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x20,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3226 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lb r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 12283 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LB_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3240 "./mips.igen"
    do_lb (SD_,RT,OFFSET,BASE);
  }
#line 12311 "semantics.c"
  return nia;
  /* Extraction: LB
       #undef do-not-use-icache
       6.0x20,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#undef TBASE
#undef TRT
#undef ERT
#line 12323 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LH_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LH_NORMAL
#undef LH_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LH_NORMAL
#undef MY_NAME
#define MY_NAME "LH_NORMAL"

  /* Extraction: LH
       #define do-not-use-icache
       6.0x21,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TBASE
#define TBASE ((int) ((BASE < 2) ? (16 + BASE) : BASE)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#line 12356 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x21,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3329 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lh r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 12375 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LH_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3343 "./mips.igen"
    do_lh (SD_,RT,OFFSET,BASE);
  }
#line 12403 "semantics.c"
  return nia;
  /* Extraction: LH
       #undef do-not-use-icache
       6.0x21,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#undef TBASE
#undef TRT
#undef ERT
#line 12415 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LWL_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LWL_NORMAL
#undef LWL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LWL_NORMAL
#undef MY_NAME
#define MY_NAME "LWL_NORMAL"

  /* Extraction: LWL
       #define do-not-use-icache
       6.0x22,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TBASE
#define TBASE ((int) ((BASE < 2) ? (16 + BASE) : BASE)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#line 12448 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x22,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3456 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lwl r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 12467 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LWL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3470 "./mips.igen"
    do_lwl (SD_, RT, OFFSET, BASE);
  }
#line 12495 "semantics.c"
  return nia;
  /* Extraction: LWL
       #undef do-not-use-icache
       6.0x22,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#undef TBASE
#undef TRT
#undef ERT
#line 12507 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LW_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LW_NORMAL
#undef LW_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LW_NORMAL
#undef MY_NAME
#define MY_NAME "LW_NORMAL"

  /* Extraction: LW
       #define do-not-use-icache
       6.0x23,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TBASE
#define TBASE ((int) ((BASE < 2) ? (16 + BASE) : BASE)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#line 12540 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x23,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3418 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lw r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 12559 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LW_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3432 "./mips.igen"
    do_lw (SD_,RT,OFFSET,BASE);
  }
#line 12587 "semantics.c"
  return nia;
  /* Extraction: LW
       #undef do-not-use-icache
       6.0x23,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#undef TBASE
#undef TRT
#undef ERT
#line 12599 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LBU_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LBU_NORMAL
#undef LBU_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LBU_NORMAL
#undef MY_NAME
#define MY_NAME "LBU_NORMAL"

  /* Extraction: LBU
       #define do-not-use-icache
       6.0x24,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TBASE
#define TBASE ((int) ((BASE < 2) ? (16 + BASE) : BASE)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#line 12632 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x24,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3245 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lbu r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 12651 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LBU_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3259 "./mips.igen"
    do_lbu (SD_, RT,OFFSET,BASE);
  }
#line 12679 "semantics.c"
  return nia;
  /* Extraction: LBU
       #undef do-not-use-icache
       6.0x24,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#undef TBASE
#undef TRT
#undef ERT
#line 12691 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LHU_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LHU_NORMAL
#undef LHU_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LHU_NORMAL
#undef MY_NAME
#define MY_NAME "LHU_NORMAL"

  /* Extraction: LHU
       #define do-not-use-icache
       6.0x25,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TBASE
#define TBASE ((int) ((BASE < 2) ? (16 + BASE) : BASE)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#line 12724 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x25,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3348 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lhu r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 12743 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LHU_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3362 "./mips.igen"
    do_lhu (SD_,RT,OFFSET,BASE);
  }
#line 12771 "semantics.c"
  return nia;
  /* Extraction: LHU
       #undef do-not-use-icache
       6.0x25,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#undef TBASE
#undef TRT
#undef ERT
#line 12783 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LWR_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LWR_NORMAL
#undef LWR_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LWR_NORMAL
#undef MY_NAME
#define MY_NAME "LWR_NORMAL"

  /* Extraction: LWR
       #define do-not-use-icache
       6.0x26,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TBASE
#define TBASE ((int) ((BASE < 2) ? (16 + BASE) : BASE)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#line 12816 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x26,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3475 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lwr r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 12835 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LWR_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3489 "./mips.igen"
    do_lwr (SD_, RT, OFFSET, BASE);
  }
#line 12863 "semantics.c"
  return nia;
  /* Extraction: LWR
       #undef do-not-use-icache
       6.0x26,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#undef TBASE
#undef TRT
#undef ERT
#line 12875 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SB_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SB_NORMAL
#undef SB_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SB_NORMAL
#undef MY_NAME
#define MY_NAME "SB_NORMAL"

  /* Extraction: SB
       #define do-not-use-icache
       6.0x28,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TBASE
#define TBASE ((int) ((BASE < 2) ? (16 + BASE) : BASE)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#line 12908 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x28,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4080 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sb r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 12927 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SB_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4094 "./mips.igen"
    do_store (SD_, AccessLength_BYTE, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 12955 "semantics.c"
  return nia;
  /* Extraction: SB
       #undef do-not-use-icache
       6.0x28,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#undef TBASE
#undef TRT
#undef ERT
#line 12967 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SH_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SH_NORMAL
#undef SH_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SH_NORMAL
#undef MY_NAME
#define MY_NAME "SH_NORMAL"

  /* Extraction: SH
       #define do-not-use-icache
       6.0x29,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TBASE
#define TBASE ((int) ((BASE < 2) ? (16 + BASE) : BASE)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#line 13000 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x29,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4194 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sh r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 13019 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SH_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4208 "./mips.igen"
    do_store (SD_, AccessLength_HALFWORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 13047 "semantics.c"
  return nia;
  /* Extraction: SH
       #undef do-not-use-icache
       6.0x29,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#undef TBASE
#undef TRT
#undef ERT
#line 13059 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SWL_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SWL_NORMAL
#undef SWL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SWL_NORMAL
#undef MY_NAME
#define MY_NAME "SWL_NORMAL"

  /* Extraction: SWL
       #define do-not-use-icache
       6.0x2a,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TBASE
#define TBASE ((int) ((BASE < 2) ? (16 + BASE) : BASE)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#line 13092 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2a,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4593 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "swl r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 13111 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SWL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4607 "./mips.igen"
    do_store_left (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 13139 "semantics.c"
  return nia;
  /* Extraction: SWL
       #undef do-not-use-icache
       6.0x2a,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#undef TBASE
#undef TRT
#undef ERT
#line 13151 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SW_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SW_NORMAL
#undef SW_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SW_NORMAL
#undef MY_NAME
#define MY_NAME "SW_NORMAL"

  /* Extraction: SW
       #define do-not-use-icache
       6.0x2b,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TBASE
#define TBASE ((int) ((BASE < 2) ? (16 + BASE) : BASE)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#line 13184 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2b,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4555 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sw r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 13203 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SW_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4569 "./mips.igen"
    do_sw (SD_, RT, OFFSET, BASE);
  }
#line 13231 "semantics.c"
  return nia;
  /* Extraction: SW
       #undef do-not-use-icache
       6.0x2b,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#undef TBASE
#undef TRT
#undef ERT
#line 13243 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SWR_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SWR_NORMAL
#undef SWR_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SWR_NORMAL
#undef MY_NAME
#define MY_NAME "SWR_NORMAL"

  /* Extraction: SWR
       #define do-not-use-icache
       6.0x2e,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TBASE
#define TBASE ((int) ((BASE < 2) ? (16 + BASE) : BASE)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#line 13276 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2e,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4612 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "swr r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 13295 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SWR_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4626 "./mips.igen"
    do_store_right (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 13323 "semantics.c"
  return nia;
  /* Extraction: SWR
       #undef do-not-use-icache
       6.0x2e,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#undef TBASE
#undef TRT
#undef ERT
#line 13335 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CACHE_NORMAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CACHE_NORMAL
#undef CACHE_NORMAL
#undef MY_PREFIX
#define MY_PREFIX CACHE_NORMAL
#undef MY_NAME
#define MY_NAME "CACHE_NORMAL"

  /* Extraction: CACHE
       #define do-not-use-icache
       6.0x2f,5.BASE,5.OP,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OP
#define OP ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TBASE
#define TBASE ((int) ((BASE < 2) ? (16 + BASE) : BASE)) /* scratch - extraction */
#line 13364 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2f,5.BASE,5.OP,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 6307 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cache %ld, %ld(r%ld)", \
                    (long) OP, \
                    (long) OFFSET, \
                    (long) BASE);
#line 13383 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CACHE_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 6319 "./mips.igen"
    address_word base = GPR[BASE];
    address_word offset = EXTEND16 (OFFSET);
    {
      address_word vaddr = loadstore_ea (SD_, base, offset);
      address_word paddr = vaddr;
      CacheOp(OP, vaddr, paddr, instruction_0);
    }
  }
#line 13417 "semantics.c"
  return nia;
  /* Extraction: CACHE
       #undef do-not-use-icache
       6.0x2f,5.BASE,5.OP,16.OFFSET */

#undef BASE
#undef OP
#undef OFFSET
#undef TBASE
#line 13427 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LWCz_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LWCz_NORMAL
#undef LWCz_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LWCz_NORMAL
#undef MY_NAME
#define MY_NAME "LWCz_NORMAL"

  /* Extraction: LWCz
       #define do-not-use-icache
       4.0xc,2.ZZ!0!1!3,5.BASE,5.RT,16.OFFSET */

#undef ZZ
#define ZZ ((unsigned) EXTRACTED32 (instruction_0, 27, 26)) /* cache - extraction */
#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TBASE
#define TBASE ((int) ((BASE < 2) ? (16 + BASE) : BASE)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#line 13462 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 4.0xc,2.ZZ!0!1!3,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3437 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lwc%ld r%ld, %ld(r%ld)", \
                    (long) ZZ, \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 13482 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LWCz_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3451 "./mips.igen"
    do_lwc (SD_, ZZ, RT, OFFSET, BASE);
  }
#line 13510 "semantics.c"
  return nia;
  /* Extraction: LWCz
       #undef do-not-use-icache
       4.0xc,2.ZZ!0!1!3,5.BASE,5.RT,16.OFFSET */

#undef ZZ
#undef BASE
#undef RT
#undef OFFSET
#undef TBASE
#undef TRT
#undef ERT
#line 13523 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LL_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LL_NORMAL
#undef LL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LL_NORMAL
#undef MY_NAME
#define MY_NAME "LL_NORMAL"

  /* Extraction: LL
       #define do-not-use-icache
       6.0x30,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TBASE
#define TBASE ((int) ((BASE < 2) ? (16 + BASE) : BASE)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#line 13556 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x30,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3367 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ll r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 13575 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3379 "./mips.igen"
    do_ll (SD_, RT, OFFSET, BASE);
  }
#line 13603 "semantics.c"
  return nia;
  /* Extraction: LL
       #undef do-not-use-icache
       6.0x30,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#undef TBASE
#undef TRT
#undef ERT
#line 13615 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LWC1_COP1 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LWC1_COP1
#undef LWC1_COP1
#undef MY_PREFIX
#define MY_PREFIX LWC1_COP1
#undef MY_NAME
#define MY_NAME "LWC1_COP1"

  /* Extraction: LWC1
       #define do-not-use-icache
       6.0x31,5.BASE,5.FT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TBASE
#define TBASE ((int) ((BASE < 2) ? (16 + BASE) : BASE)) /* scratch - extraction */
#line 13644 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x31,5.BASE,5.FT,16.OFFSET */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5675 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lwc1 f%ld, %ld(r%ld)", \
                    (long) FT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 13677 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LWC1_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5689 "./mips.igen"
    do_lwc1 (SD_, FT, OFFSET, BASE);
  }
#line 13705 "semantics.c"
  return nia;
  /* Extraction: LWC1
       #undef do-not-use-icache
       6.0x31,5.BASE,5.FT,16.OFFSET */

#undef BASE
#undef FT
#undef OFFSET
#undef TBASE
#line 13715 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_PREF_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_PREF_NORMAL
#undef PREF_NORMAL
#undef MY_PREFIX
#define MY_PREFIX PREF_NORMAL
#undef MY_NAME
#define MY_NAME "PREF_NORMAL"

  /* Extraction: PREF
       #define do-not-use-icache
       6.0x33,5.BASE,5.HINT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef HINT
#define HINT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TBASE
#define TBASE ((int) ((BASE < 2) ? (16 + BASE) : BASE)) /* scratch - extraction */
#line 13744 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x33,5.BASE,5.HINT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3948 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "pref %ld, %ld(r%ld)", \
                    (long) HINT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 13763 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_PREF_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3957 "./mips.igen"
    do_pref (SD_, HINT, OFFSET, BASE);
  }
#line 13791 "semantics.c"
  return nia;
  /* Extraction: PREF
       #undef do-not-use-icache
       6.0x33,5.BASE,5.HINT,16.OFFSET */

#undef BASE
#undef HINT
#undef OFFSET
#undef TBASE
#line 13801 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LDC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LDC1b_COP1
#undef LDC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX LDC1b_COP1
#undef MY_NAME
#define MY_NAME "LDC1b_COP1"

  /* Extraction: LDC1b
       #define do-not-use-icache
       6.0x35,5.BASE,5.FT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TBASE
#define TBASE ((int) ((BASE < 2) ? (16 + BASE) : BASE)) /* scratch - extraction */
#line 13830 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x35,5.BASE,5.FT,16.OFFSET */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5616 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ldc1 f%ld, %ld(r%ld)", \
                    (long) FT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 13863 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LDC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5626 "./mips.igen"
    check_fpu (SD_);
    COP_LD (1, FT, do_load (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 13892 "semantics.c"
  return nia;
  /* Extraction: LDC1b
       #undef do-not-use-icache
       6.0x35,5.BASE,5.FT,16.OFFSET */

#undef BASE
#undef FT
#undef OFFSET
#undef TBASE
#line 13902 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SWCz_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SWCz_NORMAL
#undef SWCz_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SWCz_NORMAL
#undef MY_NAME
#define MY_NAME "SWCz_NORMAL"

  /* Extraction: SWCz
       #define do-not-use-icache
       4.0xe,2.ZZ!0!1!3,5.BASE,5.RT,16.OFFSET */

#undef ZZ
#define ZZ ((unsigned) EXTRACTED32 (instruction_0, 27, 26)) /* cache - extraction */
#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TBASE
#define TBASE ((int) ((BASE < 2) ? (16 + BASE) : BASE)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#line 13937 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 4.0xe,2.ZZ!0!1!3,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4574 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "swc%ld r%ld, %ld(r%ld)", \
                    (long) ZZ, \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 13957 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SWCz_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4588 "./mips.igen"
    do_store (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), COP_SW (ZZ, RT));
  }
#line 13985 "semantics.c"
  return nia;
  /* Extraction: SWCz
       #undef do-not-use-icache
       4.0xe,2.ZZ!0!1!3,5.BASE,5.RT,16.OFFSET */

#undef ZZ
#undef BASE
#undef RT
#undef OFFSET
#undef TBASE
#undef TRT
#undef ERT
#line 13998 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SC_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SC_NORMAL
#undef SC_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SC_NORMAL
#undef MY_NAME
#define MY_NAME "SC_NORMAL"

  /* Extraction: SC
       #define do-not-use-icache
       6.0x38,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TBASE
#define TBASE ((int) ((BASE < 2) ? (16 + BASE) : BASE)) /* scratch - extraction */
#undef TRT
#define TRT ((int) ((RT < 2) ? (16 + RT) : RT)) /* scratch - extraction */
#undef ERT
#define ERT ((int) (compute_movep_src_reg (SD_, RT))) /* scratch - extraction */
#line 14031 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x38,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4099 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sc r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 14050 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SC_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4111 "./mips.igen"
    do_sc (SD_, RT, OFFSET, BASE, instruction_0);
  }
#line 14078 "semantics.c"
  return nia;
  /* Extraction: SC
       #undef do-not-use-icache
       6.0x38,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#undef TBASE
#undef TRT
#undef ERT
#line 14090 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SWC1_COP1 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SWC1_COP1
#undef SWC1_COP1
#undef MY_PREFIX
#define MY_PREFIX SWC1_COP1
#undef MY_NAME
#define MY_NAME "SWC1_COP1"

  /* Extraction: SWC1
       #define do-not-use-icache
       6.0x39,5.BASE,5.FT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TBASE
#define TBASE ((int) ((BASE < 2) ? (16 + BASE) : BASE)) /* scratch - extraction */
#line 14119 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x39,5.BASE,5.FT,16.OFFSET */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 6167 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "swc1 f%ld, %ld(r%ld)", \
                    (long) FT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 14152 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SWC1_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 6181 "./mips.igen"
    do_swc1 (SD_, FT, OFFSET, BASE, instruction_0);
  }
#line 14180 "semantics.c"
  return nia;
  /* Extraction: SWC1
       #undef do-not-use-icache
       6.0x39,5.BASE,5.FT,16.OFFSET */

#undef BASE
#undef FT
#undef OFFSET
#undef TBASE
#line 14190 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SDC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SDC1b_COP1
#undef SDC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX SDC1b_COP1
#undef MY_NAME
#define MY_NAME "SDC1b_COP1"

  /* Extraction: SDC1b
       #define do-not-use-icache
       6.0x3d,5.BASE,5.FT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#undef TBASE
#define TBASE ((int) ((BASE < 2) ? (16 + BASE) : BASE)) /* scratch - extraction */
#line 14219 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x3d,5.BASE,5.FT,16.OFFSET */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 6070 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sdc1 f%ld, %ld(r%ld)", \
                    (long) FT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 14252 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SDC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 6080 "./mips.igen"
    check_fpu (SD_);
    do_store (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET), COP_SD (1, FT));
  }
#line 14281 "semantics.c"
  return nia;
  /* Extraction: SDC1b
       #undef do-not-use-icache
       6.0x3d,5.BASE,5.FT,16.OFFSET */

#undef BASE
#undef FT
#undef OFFSET
#undef TBASE
#line 14291 "semantics.c"
}

#endif /* _SEMANTICS_C_*/
